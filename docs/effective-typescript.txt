effective-typescript-main/README.md
- **Chapter 1: Getting to Know TypeScript**
  - [:memo: Item 1](/samples/ch-intro/ts-vs-js.md): Understand the Relationship Between TypeScript and JavaScript
  - [:memo: Item 2](/samples/ch-intro/which-ts.md): Know Which TypeScript Options You're Using
  - [:memo: Item 3](/samples/ch-intro/independent.md): Understand That Code Generation Is Independent of Types
  - [:memo: Item 4](/samples/ch-intro/structural.md): Get Comfortable with Structural Typing
  - [:memo: Item 5](/samples/ch-intro/any.md): Limit Use of the `any` Type

- **Chapter 2: TypeScript's Type System**
  - [:memo: Item 6](/samples/ch-types/editor.md): Use Your Editor to Interrogate and Explore the Type System
  - [:memo: Item 7](/samples/ch-types/types-as-sets.md): Think of Types as Sets of Values
  - [:memo: Item 8](/samples/ch-types/type-value-space.md): Know How to Tell Whether a Symbol Is in the Type Space or Value Space
  - [:memo: Item 9](/samples/ch-types/prefer-declarations-to-assertions.md): Prefer Type Annotations to Type Assertions
  - [:memo: Item 10](/samples/ch-types/avoid-object-wrapper-types.md): Avoid Object Wrapper Types (String, Number, Boolean, Symbol, BigInt)
  - [:memo: Item 11](/samples/ch-types/excess-property-checking.md): Distinguish Excess Property Checking from Type Checking
  - [:memo: Item 12](/samples/ch-types/type-entire-functions.md): Apply Types to Entire Function Expressions When Possible
  - [:memo: Item 13](/samples/ch-types/type-vs-interface.md): Know the Differences Between `type` and `interface`
  - [:memo: Item 14](/samples/ch-types/readonly.md): Use `readonly` to Avoid Errors Associated with Mutation
  - [:memo: Item 15](/samples/ch-types/map-between-types.md): Use Type Operations and Generic Types to Avoid Repeating Yourself
  - [:memo: Item 16](/samples/ch-types/index-for-dynamic.md): Prefer More Precise Alternatives to Index Signatures
  - [:memo: Item 17](/samples/ch-types/number-index.md): Avoid Numeric Index Signatures

- **Chapter 3: Type Inference and Control Flow Analysis**
  - [:memo: Item 18](/samples/ch-inference/avoid-inferable.md): Avoid Cluttering Your Code with Inferable Types
  - [:memo: Item 19](/samples/ch-inference/one-var-one-type.md): Use Different Variables for Different Types
  - [:memo: Item 20](/samples/ch-inference/widening.md): Understand How a Variable Gets Its Type
  - [:memo: Item 21](/samples/ch-inference/all-at-once.md): Create Objects All at Once
  - [:memo: Item 22](/samples/ch-inference/narrowing.md): Understand Type Narrowing
  - [:memo: Item 23](/samples/ch-inference/avoid-aliasing.md): Be Consistent in Your Use of Aliases
  - [:memo: Item 24](/samples/ch-inference/context-inference.md): Understand How Context Is Used in Type Inference
  - [:memo: Item 25](/samples/ch-inference/evolving-any.md): Understand Evolving Types
  - [:memo: Item 26](/samples/ch-inference/functional-libraries.md): Use Functional Constructs and Libraries to Help Types Flow
  - [:memo: Item 27](/samples/ch-inference/use-async-await.md): Use async Functions Instead of Callbacks to Improve Type Flow
  - [:memo: Item 28](/samples/ch-inference/inference-sites.md): Use Classes and Currying to Create New Inference Sites

- **Chapter 4: Type Design**
  - [:memo: Item 29](/samples/ch-design/valid-states.md): Prefer Types That Always Represent Valid States
  - [:memo: Item 30](/samples/ch-design/loose-accept-strict-produce.md): Be Liberal in What You Accept and Strict in What You Produce
  - [:memo: Item 31](/samples/ch-design/jsdoc-repeat.md): Don’t Repeat Type Information in Documentation
  - [:memo: Item 32](/samples/ch-design/null-in-type.md): Avoid Including `null` or `undefined` in Type Aliases
  - [:memo: Item 33](/samples/ch-design/null-values-to-perimeter.md): Push Null Values to the Perimeter of Your Types
  - [:memo: Item 34](/samples/ch-design/union-of-interfaces.md): Prefer Unions of Interfaces to Interfaces with Unions
  - [:memo: Item 35](/samples/ch-design/avoid-strings.md): Prefer More Precise Alternatives to String Types
  - [:memo: Item 36](/samples/ch-design/in-domain-null.md): Use a Distinct Type for Special Values
  - [:memo: Item 37](/samples/ch-design/avoid-optional.md): Limit the Use of Optional Properties
  - [:memo: Item 38](/samples/ch-design/same-type-params.md): Avoid Repeated Parameters of the Same Type
  - [:memo: Item 39](/samples/ch-design/unify.md): Prefer Unifying Types to Modeling Differences
  - [:memo: Item 40](/samples/ch-design/incomplete-over-inaccurate.md): Prefer Imprecise Types to Inaccurate Types
  - [:memo: Item 41](/samples/ch-design/language-of-domain.md): Name Types Using the Language of Your Problem Domain
  - [:memo: Item 42](/samples/ch-design/consider-codegen.md): Avoid Types Based on Anecdotal Data

- **Chapter 5: Unsoundness and the any Type**
  - [:memo: Item 43](/samples/ch-any/narrowest-any.md): Use the Narrowest Possible Scope for `any` Types
  - [:memo: Item 44](/samples/ch-any/specific-any.md): Prefer More Precise Variants of `any` to Plain `any`
  - [:memo: Item 45](/samples/ch-any/hide-unsafe-casts.md): Hide Unsafe Type Assertions in Well-Typed Functions
  - [:memo: Item 46](/samples/ch-any/never-unknown.md): Use unknown Instead of `any` for Values with an Unknown Type
  - [:memo: Item 47](/samples/ch-any/type-safe-monkey.md): Prefer Type-Safe Approaches to Monkey Patching
  - [:memo: Item 48](/samples/ch-any/unsoundness.md): Avoid Soundness Traps
  - [:memo: Item 49](/samples/ch-any/type-percentage.md): Track Your Type Coverage to Prevent Regressions in Type Safety

- **Chapter 6: Generics and Type-Level Programming**
  - [:memo: Item 50](/samples/ch-generics/functions-on-types.md): Think of Generics as Functions Between Types
  - [:memo: Item 51](/samples/ch-generics/golden-rule.md): Avoid Unnecessary Type Parameters
  - [:memo: Item 52](/samples/ch-generics/conditional-overload.md): Prefer Conditional Types to Overload Signatures
  - [:memo: Item 53](/samples/ch-generics/control-distribution.md): Know How to Control the Distribution of Unions over Conditional Types
  - [:memo: Item 54](/samples/ch-generics/template-dsl.md): Use Template Literal Types to Model DSLs and Relationships Between Strings
  - [:memo: Item 55](/samples/ch-generics/test-your-types.md): Write Tests for Your Types
  - [:memo: Item 56](/samples/ch-generics/type-display.md): Pay Attention to How Types Display
  - [:memo: Item 57](/samples/ch-generics/tail-recursion.md): Prefer Tail-Recursive Generic Types
  - [:memo: Item 58](/samples/ch-generics/codegen-alt.md): Consider Codegen as an Alternative to Complex Types

- **Chapter 7: TypeScript Recipes**
  - [:memo: Item 59](/samples/ch-recipes/exhaustiveness.md): Use `never` Types to Perform Exhaustiveness Checking
  - [:memo: Item 60](/samples/ch-recipes/iterate-objects.md): Know How to Iterate Over Objects
  - [:memo: Item 61](/samples/ch-recipes/values-in-sync.md): Use `Record` Types to Keep Values in Sync
  - [:memo: Item 62](/samples/ch-recipes/conditional-varargs.md): Use Rest Parameters and Tuple Types to Model Variadic Functions
  - [:memo: Item 63](/samples/ch-recipes/optional-never.md): Use Optional `never` Properties to Model Exclusive Or
  - [:memo: Item 64](/samples/ch-recipes/brands.md): Consider Brands for Nominal Typing

- **Chapter 8: Type Declarations and @types**
  - [:memo: Item 65](/samples/ch-declarations/dev-dependencies.md): Put TypeScript and `@types` in `devDependencies`
  - [:memo: Item 66](/samples/ch-declarations/three-versions.md): Understand the Three Versions Involved in Type Declarations
  - [:memo: Item 67](/samples/ch-declarations/export-your-types.md): Export All Types That Appear in Public APIs
  - [:memo: Item 68](/samples/ch-declarations/use-tsdoc.md): Use TSDoc for API Comments
  - [:memo: Item 69](/samples/ch-declarations/this-in-callbacks.md): Provide a Type for `this` in Callbacks if It's Part of Their API
  - [:memo: Item 70](/samples/ch-declarations/mirror-types-for-deps.md): Mirror Types to Sever Dependencies
  - [:memo: Item 71](/samples/ch-declarations/augment-improve.md): Use Module Augmentation to Improve Types

- **Chapter 9: Writing and Running Your Code**
  - [:memo: Item 72](/samples/ch-write-run/avoid-non-ecma.md): Prefer ECMAScript Features to TypeScript Features
  - [:memo: Item 73](/samples/ch-write-run/source-maps-debug.md): Use Source Maps to Debug TypeScript
  - [:memo: Item 74](/samples/ch-write-run/runtime-types.md): Know How to Reconstruct Types at Runtime
  - [:memo: Item 75](/samples/ch-write-run/understand-the-dom.md): Understand the DOM Hierarchy
  - [:memo: Item 76](/samples/ch-write-run/model-env.md): Create an Accurate Model of Your Environment
  - [:memo: Item 77](/samples/ch-write-run/types-or-tests.md): Understand the Relationship Between Type Checking and Unit Testing
  - [:memo: Item 78](/samples/ch-write-run/performance.md): Pay Attention to Compiler Performance

- **Chapter 10: Modernization and Migration**
  - [:memo: Item 79](/samples/ch-migrate/write-modern-js.md): Write Modern JavaScript
  - [:memo: Item 80](/samples/ch-migrate/jsdoc-tscheck.md): Use `@ts-check` and JSDoc to Experiment with TypeScript
  - [:memo: Item 81](/samples/ch-migrate/allowjs.md): Use `allowJs` to Mix TypeScript and JavaScript
  - [:memo: Item 82](/samples/ch-migrate/convert-up-the-graph.md): Convert Module by Module Up Your Dependency Graph
  - [:memo: Item 83](/samples/ch-migrate/start-loose.md): Don't Consider Migration Complete Until You Enable `noImplicitAny`

---
effective-typescript-main/samples/index.md
---

- **Chapter 1: Getting to Know TypeScript**
  - [:memo: Item 1](/samples/ch-intro/ts-vs-js.md): Understand the Relationship Between TypeScript and JavaScript
  - [:memo: Item 2](/samples/ch-intro/which-ts.md): Know Which TypeScript Options You're Using
  - [:memo: Item 3](/samples/ch-intro/independent.md): Understand That Code Generation Is Independent of Types
  - [:memo: Item 4](/samples/ch-intro/structural.md): Get Comfortable with Structural Typing
  - [:memo: Item 5](/samples/ch-intro/any.md): Limit Use of the any Type

- **Chapter 2: TypeScript's Type System**
  - [:memo: Item 6](/samples/ch-types/editor.md): Use Your Editor to Interrogate and Explore the Type System
  - [:memo: Item 7](/samples/ch-types/types-as-sets.md): Think of Types as Sets of Values
  - [:memo: Item 8](/samples/ch-types/type-value-space.md): Know How to Tell Whether a Symbol Is in the Type Space or Value Space
  - [:memo: Item 9](/samples/ch-types/prefer-declarations-to-assertions.md): Prefer Type Annotations to Type Assertions
  - [:memo: Item 10](/samples/ch-types/avoid-object-wrapper-types.md): Avoid Object Wrapper Types (String, Number, Boolean, Symbol, BigInt)
  - [:memo: Item 11](/samples/ch-types/excess-property-checking.md): Distinguish Excess Property Checking from Type Checking
  - [:memo: Item 12](/samples/ch-types/type-entire-functions.md): Apply Types to Entire Function Expressions When Possible
  - [:memo: Item 13](/samples/ch-types/type-vs-interface.md): Know the Differences Between type and interface
  - [:memo: Item 14](/samples/ch-types/readonly.md): Use readonly to Avoid Errors Associated with Mutation
  - [:memo: Item 15](/samples/ch-types/map-between-types.md): Use Type Operations and Generic Types to Avoid Repeating Yourself
  - [:memo: Item 16](/samples/ch-types/index-for-dynamic.md): Prefer More Precise Alternatives to Index Signatures
  - [:memo: Item 17](/samples/ch-types/number-index.md): Avoid Numeric Index Signatures

- **Chapter 3: Type Inference and Control Flow Analysis**
  - [:memo: Item 18](/samples/ch-inference/avoid-inferable.md): Avoid Cluttering Your Code with Inferable Types
  - [:memo: Item 19](/samples/ch-inference/one-var-one-type.md): Use Different Variables for Different Types
  - [:memo: Item 20](/samples/ch-inference/widening.md): Understand How a Variable Gets Its Type
  - [:memo: Item 21](/samples/ch-inference/all-at-once.md): Create Objects All at Once
  - [:memo: Item 22](/samples/ch-inference/narrowing.md): Understand Type Narrowing
  - [:memo: Item 23](/samples/ch-inference/avoid-aliasing.md): Be Consistent in Your Use of Aliases
  - [:memo: Item 24](/samples/ch-inference/context-inference.md): Understand How Context Is Used in Type Inference
  - [:memo: Item 25](/samples/ch-inference/evolving-any.md): Understand Evolving Types
  - [:memo: Item 26](/samples/ch-inference/functional-libraries.md): Use Functional Constructs and Libraries to Help Types Flow
  - [:memo: Item 27](/samples/ch-inference/use-async-await.md): Use async Functions Instead of Callbacks to Improve Type Flow
  - [:memo: Item 28](/samples/ch-inference/inference-sites.md): Use Classes and Currying to Create New Inference Sites

- **Chapter 4: Type Design**
  - [:memo: Item 29](/samples/ch-design/valid-states.md): Prefer Types That Always Represent Valid States
  - [:memo: Item 30](/samples/ch-design/loose-accept-strict-produce.md): Be Liberal in What You Accept and Strict in What You Produce
  - [:memo: Item 31](/samples/ch-design/jsdoc-repeat.md): Don’t Repeat Type Information in Documentation
  - [:memo: Item 32](/samples/ch-design/null-in-type.md): Avoid Including null or undefined in Type Aliases
  - [:memo: Item 33](/samples/ch-design/null-values-to-perimeter.md): Push Null Values to the Perimeter of Your Types
  - [:memo: Item 34](/samples/ch-design/union-of-interfaces.md): Prefer Unions of Interfaces to Interfaces with Unions
  - [:memo: Item 35](/samples/ch-design/avoid-strings.md): Prefer More Precise Alternatives to String Types
  - [:memo: Item 36](/samples/ch-design/in-domain-null.md): Use a Distinct Type for Special Values
  - [:memo: Item 37](/samples/ch-design/avoid-optional.md): Limit the Use of Optional Properties
  - [:memo: Item 38](/samples/ch-design/same-type-params.md): Avoid Repeated Parameters of the Same Type
  - [:memo: Item 39](/samples/ch-design/unify.md): Prefer Unifying Types to Modeling Differences
  - [:memo: Item 40](/samples/ch-design/incomplete-over-inaccurate.md): Prefer Imprecise Types to Inaccurate Types
  - [:memo: Item 41](/samples/ch-design/language-of-domain.md): Name Types Using the Language of Your Problem Domain
  - [:memo: Item 42](/samples/ch-design/consider-codegen.md): Avoid Types Based on Anecdotal Data

- **Chapter 5: Unsoundness and the any Type**
  - [:memo: Item 43](/samples/ch-any/narrowest-any.md): Use the Narrowest Possible Scope for any Types
  - [:memo: Item 44](/samples/ch-any/specific-any.md): Prefer More Precise Variants of any to Plain any
  - [:memo: Item 45](/samples/ch-any/hide-unsafe-casts.md): Hide Unsafe Type Assertions in Well-Typed Functions
  - [:memo: Item 46](/samples/ch-any/never-unknown.md): Use unknown Instead of any for Values with an Unknown Type
  - [:memo: Item 47](/samples/ch-any/type-safe-monkey.md): Prefer Type-Safe Approaches to Monkey Patching
  - [:memo: Item 48](/samples/ch-any/unsoundness.md): Avoid Soundness Traps
  - [:memo: Item 49](/samples/ch-any/type-percentage.md): Track Your Type Coverage to Prevent Regressions in Type Safety

- **Chapter 6: Generics and Type-Level Programming**
  - [:memo: Item 50](/samples/ch-generics/functions-on-types.md): Think of Generics as Functions Between Types
  - [:memo: Item 51](/samples/ch-generics/golden-rule.md): Avoid Unnecessary Type Parameters
  - [:memo: Item 52](/samples/ch-generics/conditional-overload.md): Prefer Conditional Types to Overload Signatures
  - [:memo: Item 53](/samples/ch-generics/control-distribution.md): Know How to Control the Distribution of Unions over Conditional Types
  - [:memo: Item 54](/samples/ch-generics/template-dsl.md): Use Template Literal Types to Model DSLs and Relationships Between Strings
  - [:memo: Item 55](/samples/ch-generics/test-your-types.md): Write Tests for Your Types
  - [:memo: Item 56](/samples/ch-generics/type-display.md): Pay Attention to How Types Display
  - [:memo: Item 57](/samples/ch-generics/tail-recursion.md): Prefer Tail-Recursive Generic Types
  - [:memo: Item 58](/samples/ch-generics/codegen-alt.md): Consider Codegen as an Alternative to Complex Types

- **Chapter 7: TypeScript Recipes**
  - [:memo: Item 59](/samples/ch-recipes/exhaustiveness.md): Use Never Types to Perform Exhaustiveness Checking
  - [:memo: Item 60](/samples/ch-recipes/iterate-objects.md): Know How to Iterate Over Objects
  - [:memo: Item 61](/samples/ch-recipes/values-in-sync.md): Use Record Types to Keep Values in Sync
  - [:memo: Item 62](/samples/ch-recipes/conditional-varargs.md): Use Rest Parameters and Tuple Types to Model Variadic Functions
  - [:memo: Item 63](/samples/ch-recipes/optional-never.md): Use Optional Never Properties to Model Exclusive Or
  - [:memo: Item 64](/samples/ch-recipes/brands.md): Consider Brands for Nominal Typing

- **Chapter 8: Type Declarations and @types**
  - [:memo: Item 65](/samples/ch-declarations/dev-dependencies.md): Put TypeScript and @types in devDependencies
  - [:memo: Item 66](/samples/ch-declarations/three-versions.md): Understand the Three Versions Involved in Type Declarations
  - [:memo: Item 67](/samples/ch-declarations/export-your-types.md): Export All Types That Appear in Public APIs
  - [:memo: Item 68](/samples/ch-declarations/use-tsdoc.md): Use TSDoc for API Comments
  - [:memo: Item 69](/samples/ch-declarations/this-in-callbacks.md): Provide a Type for this in Callbacks if It's Part of Their API
  - [:memo: Item 70](/samples/ch-declarations/mirror-types-for-deps.md): Mirror Types to Sever Dependencies
  - [:memo: Item 71](/samples/ch-declarations/augment-improve.md): Use Module Augmentation to Improve Types

- **Chapter 9: Writing and Running Your Code**
  - [:memo: Item 72](/samples/ch-write-run/avoid-non-ecma.md): Prefer ECMAScript Features to TypeScript Features
  - [:memo: Item 73](/samples/ch-write-run/source-maps-debug.md): Use Source Maps to Debug TypeScript
  - [:memo: Item 74](/samples/ch-write-run/runtime-types.md): Know How to Reconstruct Types at Runtime
  - [:memo: Item 75](/samples/ch-write-run/understand-the-dom.md): Understand the DOM Hierarchy
  - [:memo: Item 76](/samples/ch-write-run/model-env.md): Create an Accurate Model of Your Environment
  - [:memo: Item 77](/samples/ch-write-run/types-or-tests.md): Understand the Relationship Between Type Checking and Unit Testing
  - [:memo: Item 78](/samples/ch-write-run/performance.md): Pay Attention to Compiler Performance

- **Chapter 10: Modernization and Migration**
  - [:memo: Item 79](/samples/ch-migrate/write-modern-js.md): Write Modern JavaScript
  - [:memo: Item 80](/samples/ch-migrate/jsdoc-tscheck.md): Use @ts-check and JSDoc to Experiment with TypeScript
  - [:memo: Item 81](/samples/ch-migrate/allowjs.md): Use allowJs to Mix TypeScript and JavaScript
  - [:memo: Item 82](/samples/ch-migrate/convert-up-the-graph.md): Convert Module by Module Up Your Dependency Graph
  - [:memo: Item 83](/samples/ch-migrate/start-loose.md): Don't Consider Migration Complete Until You Enable noImplicitAny

---
effective-typescript-main/samples/ch-inference/avoid-aliasing.md
---
# Item 23: Be Consistent in Your Use of Aliases

## Things to Remember

- Aliasing can prevent TypeScript from narrowing types. If you create an alias for a variable, use it consistently.
- Be aware of how function calls can invalidate type refinements on properties. Trust refinements on local variables more than on properties.


## Code Samples

```ts
const place = {name: 'New York', latLng: [41.6868, -74.2692]};
const loc = place.latLng;
```


----

```ts
interface Coordinate {
  x: number;
  y: number;
}

interface BoundingBox {
  x: [number, number];
  y: [number, number];
}

interface Polygon {
  exterior: Coordinate[];
  holes: Coordinate[][];
  bbox?: BoundingBox;
}
```


----

```ts
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  if (polygon.bbox) {
    if (pt.x < polygon.bbox.x[0] || pt.x > polygon.bbox.x[1] ||
        pt.y < polygon.bbox.y[0] || pt.y > polygon.bbox.y[1]) {
      return false;
    }
  }

  // ... more complex check
}
```
----

```ts
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const box = polygon.bbox;
  if (polygon.bbox) {
    if (pt.x < box.x[0] || pt.x > box.x[1] ||
        //     ~~~                ~~~  'box' is possibly 'undefined'
        pt.y < box.y[0] || pt.y > box.y[1]) {
        //     ~~~                ~~~  'box' is possibly 'undefined'
      return false;
    }
  }
  // ...
}
```
----

```ts
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  polygon.bbox
  //      ^? (property) Polygon.bbox?: BoundingBox | undefined
  const box = polygon.bbox;
  //    ^? const box: BoundingBox | undefined
  if (polygon.bbox) {
    console.log(polygon.bbox);
    //                  ^? (property) Polygon.bbox?: BoundingBox
    console.log(box);
    //          ^? const box: BoundingBox | undefined
  }
}
```
----

```ts
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const box = polygon.bbox;
  if (box) {
    if (pt.x < box.x[0] || pt.x > box.x[1] ||
        pt.y < box.y[0] || pt.y > box.y[1]) {  // OK
      return false;
    }
  }
  // ...
}
```
----

```ts
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const {bbox} = polygon;
  if (bbox) {
    const {x, y} = bbox;
    if (pt.x < x[0] || pt.x > x[1] || pt.y < y[0] || pt.y > y[1]) {
      return false;
    }
  }
  // ...
}
```
----

```ts
const {bbox} = polygon;
if (!bbox) {
  calculatePolygonBbox(polygon);  // Fills in polygon.bbox
  // Now polygon.bbox and bbox refer to different values!
}
```
----

```ts
function expandABit(p: Polygon) { /* ... */ }

polygon.bbox
//      ^? (property) Polygon.bbox?: BoundingBox | undefined
if (polygon.bbox) {
  polygon.bbox
  //      ^? (property) Polygon.bbox?: BoundingBox
  expandABit(polygon);
  polygon.bbox
  //      ^? (property) Polygon.bbox?: BoundingBox
}
```
---
effective-typescript-main/samples/ch-inference/use-async-await.md
---
# Item 27: Use async Functions Instead of Callbacks to Improve Type Flow

## Things to Remember

- Prefer Promises to callbacks for better composability and type flow.
- Prefer `async` and `await` to raw Promises when possible. They produce more concise, straightforward code and eliminate whole classes of errors.
- If a function returns a Promise, declare it `async`.


## Code Samples

```ts
declare function fetchURL(
  url: string, callback: (response: string) => void
): void;

fetchURL(url1, function(response1) {
  fetchURL(url2, function(response2) {
    fetchURL(url3, function(response3) {
      // ...
      console.log(1);
    });
    console.log(2);
  });
  console.log(3);
});
console.log(4);

// Logs:
// 4
// 3
// 2
// 1
```
----

```ts
const page1Promise = fetch(url1);
page1Promise.then(response1 => {
  return fetch(url2);
}).then(response2 => {
  return fetch(url3);
}).then(response3 => {
  // ...
}).catch(error => {
  // ...
});
```----

```ts
async function fetchPages() {
  const response1 = await fetch(url1);
  const response2 = await fetch(url2);
  const response3 = await fetch(url3);
  // ...
}
```
----

```ts
async function fetchPages() {
  try {
    const response1 = await fetch(url1);
    const response2 = await fetch(url2);
    const response3 = await fetch(url3);
    // ...
  } catch (e) {
    // ...
  }
}
```
----

```ts
async function fetchPages() {
  const [response1, response2, response3] = await Promise.all([
    fetch(url1), fetch(url2), fetch(url3)
  ]);
  // ...
}
```
----

```ts
function fetchPagesWithCallbacks() {
  let numDone = 0;
  const responses: string[] = [];
  const done = () => {
    const [response1, response2, response3] = responses;
    // ...
  };
  const urls = [url1, url2, url3];
  urls.forEach((url, i) => {
    fetchURL(url, r => {
      responses[i] = url;
      numDone++;
      if (numDone === urls.length) done();
    });
  });
}
```
----

```ts
function timeout(timeoutMs: number): Promise<never> {
  return new Promise((resolve, reject) => {
     setTimeout(() => reject('timeout'), timeoutMs);
  });
}

async function fetchWithTimeout(url: string, timeoutMs: number) {
  return Promise.race([fetch(url), timeout(timeoutMs)]);
}
```
----

```ts
async function getNumber() { return 42; }
//             ^? function getNumber(): Promise<number>
```
----

```ts
const getNumber = async () => 42;
//    ^? const getNumber: () => Promise<number>
```
----

```ts
const getNumber = () => Promise.resolve(42);
//    ^? const getNumber: () => Promise<number>
```
----

```ts
// Don't do this!
const _cache: {[url: string]: string} = {};
function fetchWithCache(url: string, callback: (text: string) => void) {
  if (url in _cache) {
    callback(_cache[url]);
  } else {
    fetchURL(url, text => {
      _cache[url] = text;
      callback(text);
    });
  }
}
```
----

```ts
let requestStatus: 'loading' | 'success' | 'error';
function getUser(userId: string) {
  fetchWithCache(`/user/${userId}`, profile => {
    requestStatus = 'success';
  });
  requestStatus = 'loading';
}
```
----

```ts
const _cache: {[url: string]: string} = {};
async function fetchWithCache(url: string) {
  if (url in _cache) {
    return _cache[url];
  }
  const response = await fetch(url);
  const text = await response.text();
  _cache[url] = text;
  return text;
}

let requestStatus: 'loading' | 'success' | 'error';
async function getUser(userId: string) {
  requestStatus = 'loading';
  const profile = await fetchWithCache(`/user/${userId}`);
  requestStatus = 'success';
}
```
----

```ts
async function getJSON(url: string) {
  const response = await fetch(url);
  const jsonPromise = response.json();
  return jsonPromise;
  //     ^? const jsonPromise: Promise<any>
}
getJSON
// ^? function getJSON(url: string): Promise<any>
```
---
effective-typescript-main/samples/ch-inference/evolving-any.md
---
# Item 25: Understand Evolving Types

## Things to Remember

- While TypeScript types typically only _refine_, the types of values initialized to `null`, `undefined`, or `[]` are allowed to _evolve_.
- Recognize and understand this construct where it occurs, and use it to reduce the need for type annotations in your own code.
- For better error checking, consider providing an explicit type annotation instead of using evolving types.


## Code Samples

```ts
function range(start: number, limit: number) {
  const nums = [];
  for (let i = start; i < limit; i++) {
    nums.push(i);
  }
  return nums;
  //     ^? const nums: number[]
}
```
----

```ts
function range(start: number, limit: number) {
  const nums = [];
  //    ^? const nums: any[]
  for (let i = start; i < limit; i++) {
    nums.push(i);
    // ^? const nums: any[]
  }
  return nums;
  //     ^? const nums: number[]
}
```
----

```ts
const result = [];
//    ^? const result: any[]
result.push('a');
result
// ^? const result: string[]
result.push(1);
result
// ^? const result: (string | number)[]
```
----

```ts
let value;
//  ^? let value: any
if (Math.random() < 0.5) {
  value = /hello/;
  value
  // ^? let value: RegExp
} else {
  value = 12;
  value
  // ^? let value: number
}
value
// ^? let value: number | RegExp
```
----

```ts
let value = null;
//  ^? let value: any
try {
  value = doSomethingRiskyAndReturnANumber();
  value
  // ^? let value: number
} catch (e) {
  console.warn('alas!');
}
value
// ^? let value: number | null
```
----

```ts
function range(start: number, limit: number) {
  const nums = [];
  //    ~~~~ Variable 'nums' implicitly has type 'any[]' in some
  //         locations where its type cannot be determined
  if (start === limit) {
    return nums;
    //     ~~~~ Variable 'nums' implicitly has an 'any[]' type
  }
  for (let i = start; i < limit; i++) {
    nums.push(i);
  }
  return nums;
}
```
----

```ts
function makeSquares(start: number, limit: number) {
  const nums = [];
  //    ~~~~ Variable 'nums' implicitly has type 'any[]' in some locations
  range(start, limit).forEach(i => {
    nums.push(i * i);
  });
  return nums;
  //     ~~~~ Variable 'nums' implicitly has an 'any[]' type
}
```
---
effective-typescript-main/samples/ch-inference/functional-libraries.md
---
# Item 26: Use Functional Constructs and Libraries to Help Types Flow

## Things to Remember

- Use built-in functional constructs and those in utility libraries like Lodash instead of hand-rolled constructs to improve type flow, increase legibility, and reduce the need for explicit type annotations.


## Code Samples

```js
const csvData = "...";
const rawRows = csvData.split('\n');
const headers = rawRows[0].split(',');

const rows = rawRows.slice(1).map((rowStr) => {
  const row = {};
  rowStr.split(",").forEach((val, j) => {
    row[headers[j]] = val;
  });
  return row;
});
```
----

```ts
import _ from 'lodash';
const rows = rawRows.slice(1)
    .map(rowStr => _.zipObject(headers, rowStr.split(',')));
```
----

```ts
const rowsImperative = rawRows.slice(1).map(rowStr => {
  const row = {};
  rowStr.split(',').forEach((val, j) => {
    row[headers[j]] = val;
    // ~~~~~~~~~~~~ No index signature with a parameter of
    //              type 'string' was found on type '{}'
  });
  return row;
});
const rowsFunctional = rawRows.slice(1)
  .map((rowStr) =>
    rowStr
      .split(",")
      .reduce(
        (row, val, i) => ((row[headers[i]] = val), row),
        //                 ~~~~~~~~~~~~~~~ No index signature with a parameter of
        //                                 type 'string' was found on type '{}'
        {}
      )
  );
```
----

```ts
const rowsLodash =
  rawRows.slice(1).map(rowStr => _.zipObject(headers, rowStr.split(',')));
rowsLodash
// ^? const rowsLodash: _.Dictionary<string>[]
```
----

```ts
interface BasketballPlayer {
  name: string;
  team: string;
  salary: number;
}
declare const rosters: {[team: string]: BasketballPlayer[]};
```
----

```ts
let allPlayers = [];
//  ~~~~~~~~~~ Variable 'allPlayers' implicitly has type 'any[]'
//             in some locations where its type cannot be determined
for (const players of Object.values(rosters)) {
  allPlayers = allPlayers.concat(players);
  //           ~~~~~~~~~~ Variable 'allPlayers' implicitly has an 'any[]' type
}
```
----

```ts
let allPlayers: BasketballPlayer[] = [];
for (const players of Object.values(rosters)) {
  allPlayers = allPlayers.concat(players);  // OK
}
```
----

```ts
const allPlayers = Object.values(rosters).flat(); // OK
//    ^? const allPlayers: BasketballPlayer[]
```
----

```ts
const teamToPlayers: {[team: string]: BasketballPlayer[]} = {};
for (const player of allPlayers) {
  const {team} = player;
  teamToPlayers[team] = teamToPlayers[team] || [];
  teamToPlayers[team].push(player);
}

for (const players of Object.values(teamToPlayers)) {
  players.sort((a, b) => b.salary - a.salary);
}

const bestPaid = Object.values(teamToPlayers).map(players => players[0]);
bestPaid.sort((playerA, playerB) => playerB.salary - playerA.salary);
console.log(bestPaid);
```
----

```ts
const bestPaid = _(allPlayers)
  .groupBy(player => player.team)
  .mapValues(players => _.maxBy(players, p => p.salary)!)
  .values()
  .sortBy(p => -p.salary)
  .value();
console.log(bestPaid.slice(0, 10));
//          ^? const bestPaid: BasketballPlayer[]
```
---
effective-typescript-main/samples/ch-inference/context-inference.md
---
# Item 24: Understand How Context Is Used in Type Inference

## Things to Remember

- Be aware of how context is used in type inference.
- If factoring out a variable introduces a type error, maybe add a type annotation.
- If the variable is truly a constant, use a const assertion (`as const`). But be aware that this may result in errors surfacing at use, rather than definition.
- Prefer inlining values where it's practical to reduce the need for type annotations.
## Code Samples

```ts
function setLanguage(language: string) { /* ... */ }

setLanguage('JavaScript');  // OK

let language = 'JavaScript';
setLanguage(language);  // OK
```
----

```ts
type Language = 'JavaScript' | 'TypeScript' | 'Python';
function setLanguage(language: Language) { /* ... */ }

setLanguage('JavaScript');  // OK

let language = 'JavaScript';
setLanguage(language);
//          ~~~~~~~~ Argument of type 'string' is not assignable
//                   to parameter of type 'Language'
```
----

```ts
let language: Language = 'JavaScript';
setLanguage(language);  // OK
```
----

```ts
const language = 'JavaScript';
//    ^? const language: "JavaScript"
setLanguage(language);  // OK
```
----

```ts
// Parameter is a (latitude, longitude) pair.
function panTo(where: [number, number]) { /* ... */ }

panTo([10, 20]);  // OK

const loc = [10, 20];
//    ^? const loc: number[]
panTo(loc);
//    ~~~ Argument of type 'number[]' is not assignable to
//        parameter of type '[number, number]'
```
----

```ts
const loc: [number, number] = [10, 20];
panTo(loc);  // OK
```
----

```ts
const loc = [10, 20] as const;
//    ^? const loc: readonly [10, 20]
panTo(loc);
//    ~~~ The type 'readonly [10, 20]' is 'readonly'
//        and cannot be assigned to the mutable type '[number, number]'
```
----

```ts
function panTo(where: readonly [number, number]) { /* ... */ }
const loc = [10, 20] as const;
panTo(loc);  // OK
```
----

```ts
const loc = [10, 20, 30] as const;  // error is really here.
panTo(loc);
//    ~~~ Argument of type 'readonly [10, 20, 30]' is not assignable to
//        parameter of type 'readonly [number, number]'
//          Source has 3 element(s) but target allows only 2.
```
----

```ts
type Language = 'JavaScript' | 'TypeScript' | 'Python';
interface GovernedLanguage {
  language: Language;
  organization: string;
}

function complain(language: GovernedLanguage) { /* ... */ }

complain({ language: 'TypeScript', organization: 'Microsoft' });  // OK

const ts = {
  language: 'TypeScript',
  organization: 'Microsoft',
};
complain(ts);
//       ~~ Argument of type '{ language: string; organization: string; }'
//            is not assignable to parameter of type 'GovernedLanguage'
//          Types of property 'language' are incompatible
//            Type 'string' is not assignable to type 'Language'
```
----

```ts
function callWithRandomNumbers(fn: (n1: number, n2: number) => void) {
  fn(Math.random(), Math.random());
}

callWithRandomNumbers((a, b) => {
  //                   ^? (parameter) a: number
  console.log(a + b);
  //              ^? (parameter) b: number
});
```
----

```ts
const fn = (a, b) => {
  //        ~    Parameter 'a' implicitly has an 'any' type
  //           ~ Parameter 'b' implicitly has an 'any' type
  console.log(a + b);
}
callWithRandomNumbers(fn);
```
----

```ts
const fn = (a: number, b: number) => {
  console.log(a + b);
}
callWithRandomNumbers(fn);
```
---
effective-typescript-main/samples/ch-inference/all-at-once.md
---
# Item 21: Create Objects All at Once

## Things to Remember

- Prefer to build objects all at once rather than piecemeal.
- Use multiple objects and object spread syntax (`{...a, ...b}`) to add properties in a type-safe way.
- Know how to conditionally add properties to an object.

## Code Samples

```ts
const pt = {};
//    ^? const pt: {}
pt.x = 3;
// ~ Property 'x' does not exist on type '{}'
pt.y = 4;
// ~ Property 'y' does not exist on type '{}'
```
----

```ts
interface Point { x: number; y: number; }
const pt: Point = {};
   // ~~ Type '{}' is missing the following properties from type 'Point': x, y
pt.x = 3;
pt.y = 4;
```
----

```ts
const pt = {} as Point;
//    ^? const pt: Point
pt.x = 3;
pt.y = 4;  // OK
```
----

```ts
const pt: Point = {
  x: 3,
  y: 4,
};
```
----

```ts
const pt = {x: 3, y: 4};
const id = {name: 'Pythagoras'};
const namedPoint = {};
Object.assign(namedPoint, pt, id);
namedPoint.name;
        // ~~~~ Property 'name' does not exist on type '{}'
```
----

```ts
const namedPoint = {...pt, ...id};
//    ^? const namedPoint: { name: string; x: number; y: number; }
namedPoint.name;  // OK
//         ^? (property) name: string
```
----

```ts
const pt0 = {};
const pt1 = {...pt0, x: 3};
const pt: Point = {...pt1, y: 4};  // OK
```
----

```ts
declare let hasMiddle: boolean;
const firstLast = {first: 'Harry', last: 'Truman'};
const president = {...firstLast, ...(hasMiddle ? {middle: 'S'} : {})};
//    ^? const president: {
//         middle?: string;
//         first: string;
//         last: string;
//       }
// or: const president = {...firstLast, ...(hasMiddle && {middle: 'S'})};
```
----

```ts
declare let hasDates: boolean;
const nameTitle = {name: 'Khufu', title: 'Pharaoh'};
const pharaoh = { ...nameTitle, ...(hasDates && {start: -2589, end: -2566})};
//    ^? const pharaoh: {
//         start?: number;
//         end?: number;
//         name: string;
//         title: string;
//       }
```
----

```ts
const {start} = pharaoh;
//     ^? const start: number | undefined
```
---
effective-typescript-main/samples/ch-inference/one-var-one-type.md
---
# Item 19: Use Different Variables for Different Types

## Things to Remember

- While a variable's value can change, its type generally does not.
- To avoid confusion, both for human readers and for the type checker, avoid reusing variables for differently typed values.

## Code Samples

```ts
let productId = "12-34-56";
fetchProduct(productId);

productId = 123456;
// ~~~~~~ Type 'number' is not assignable to type 'string'
fetchProductBySerialNumber(productId);
//                         ~~~~~~~~~
// Argument of type 'string' is not assignable to parameter of type 'number'
```
----

```ts
let productId: string | number = "12-34-56";
fetchProduct(productId);

productId = 123456;  // OK
fetchProductBySerialNumber(productId);  // OK
```
----

```ts
const productId = "12-34-56";
fetchProduct(productId);

const serial = 123456;  // OK
fetchProductBySerialNumber(serial);  // OK
```
----

```ts
const productId = "12-34-56";
fetchProduct(productId);

{
  const productId = 123456;  // OK
  fetchProductBySerialNumber(productId);  // OK
}
```
---
effective-typescript-main/samples/ch-inference/narrowing.md
---
# Item 22: Understand Type Narrowing

## Things to Remember

- Understand how TypeScript narrows types based on conditionals and other types of control flow.
- Use tagged/discriminated unions and user-defined type guards to help the process of narrowing.
- Think about whether code can be refactored to let TypeScript follow along more easily.


## Code Samples

```ts
const elem = document.getElementById('what-time-is-it');
//    ^? const elem: HTMLElement | null
if (elem) {
  elem.innerHTML = 'Party Time'.blink();
  // ^? const elem: HTMLElement
} else {
  elem
  // ^? const elem: null
  alert('No element #what-time-is-it');
}
```
----

```ts
const elem = document.getElementById('what-time-is-it');
//    ^? const elem: HTMLElement | null
if (!elem) throw new Error('Unable to find #what-time-is-it');
elem.innerHTML = 'Party Time'.blink();
// ^? const elem: HTMLElement
```
----

```ts
function contains(text: string, search: string | RegExp) {
  if (search instanceof RegExp) {
    return !!search.exec(text);
    //       ^? (parameter) search: RegExp
  }
  return text.includes(search);
  //                   ^? (parameter) search: string
}
```
----

```ts
interface Apple { isGoodForBaking: boolean; }
interface Orange { numSlices: number; }
function pickFruit(fruit: Apple | Orange) {
  if ('isGoodForBaking' in fruit) {
    fruit
    // ^? (parameter) fruit: Apple
  } else {
    fruit
    // ^? (parameter) fruit: Orange
  }
  fruit
  // ^? (parameter) fruit: Apple | Orange
}
```
----

```ts
function contains(text: string, terms: string | string[]) {
  const termList = Array.isArray(terms) ? terms : [terms];
  //    ^? const termList: string[]
  // ...
}
```
----

```ts
const elem = document.getElementById('what-time-is-it');
//    ^? const elem: HTMLElement | null
if (typeof elem === 'object') {
  elem;
  // ^? const elem: HTMLElement | null
}
```
----

```ts
function maybeLogX(x?: number | string | null) {
  if (!x) {
    console.log(x);
    //          ^? (parameter) x: string | number | null | undefined
  }
}
```
----

```ts
interface UploadEvent { type: 'upload'; filename: string; contents: string }
interface DownloadEvent { type: 'download'; filename: string; }
type AppEvent = UploadEvent | DownloadEvent;

function handleEvent(e: AppEvent) {
  switch (e.type) {
    case 'download':
      console.log('Download', e.filename);
      //                      ^? (parameter) e: DownloadEvent
      break;
    case 'upload':
      console.log('Upload', e.filename, e.contents.length, 'bytes');
      //                    ^? (parameter) e: UploadEvent
      break;
  }
}
```
----

```ts
function isInputElement(el: Element): el is HTMLInputElement {
  return 'value' in el;
}

function getElementContent(el: HTMLElement) {
  if (isInputElement(el)) {
    return el.value;
    //     ^? (parameter) el: HTMLInputElement
  }
  return el.textContent;
  //     ^? (parameter) el: HTMLElement
}
```
----

```ts
const formEls = document.querySelectorAll('.my-form *');
const formInputEls = [...formEls].filter(isInputElement);
//    ^? const formInputEls: HTMLInputElement[]
```
----

```ts
const nameToNickname = new Map<string, string>();
declare let yourName: string;
let nameToUse: string;
if (nameToNickname.has(yourName)) {
  nameToUse = nameToNickname.get(yourName);
  // ~~~~~~ Type 'string | undefined' is not assignable to type 'string'.
} else {
  nameToUse = yourName;
}
```
----

```ts
const nickname = nameToNickname.get(yourName);
let nameToUse: string;
if (nickname !== undefined) {
  nameToUse = nickname;
} else {
  nameToUse = yourName;
}
```
----

```ts
const nameToUse = nameToNickname.get(yourName) ?? yourName;
```
----

```ts
function logLaterIfNumber(obj: { value: string | number }) {
  if (typeof obj.value === "number") {
    setTimeout(() => console.log(obj.value.toFixed()));
    //                                     ~~~~~~~
    // Property 'toFixed' does not exist on type 'string | number'.
  }
}
```
----

```ts
const obj: { value: string | number } = { value: 123 };
logLaterIfNumber(obj);
obj.value = 'Cookie Monster';
```
---
effective-typescript-main/samples/ch-inference/widening.md
---
# Item 20: Understand How a Variable Gets Its Type

## Things to Remember

- Understand how TypeScript infers a type from a literal by widening it.
- Familiarize yourself with the ways you can affect this behavior: `const`, type annotations, context, helper functions, `as const`, and `satisfies`.

## Code Samples

```ts
interface Vector3 { x: number; y: number; z: number; }
function getComponent(vector: Vector3, axis: 'x' | 'y' | 'z') {
  return vector[axis];
}
```
----

```ts
let x = 'x';
let vec = {x: 10, y: 20, z: 30};
getComponent(vec, x);
//                ~ Argument of type 'string' is not assignable
//                  to parameter of type '"x" | "y" | "z"'
```
----

```ts
const mixed = ['x', 1];
```
----

```ts
let x = 'x';
x = 'a';
x = 'Four score and seven years ago...';
```
----

```ts
const x = 'x';
//    ^? const x: "x"
let vec = {x: 10, y: 20, z: 30};
getComponent(vec, x);  // OK
```
----

```ts
const obj = {
  x: 1,
};
obj.x = 3;  // OK
obj.x = '3';
//  ~ Type 'string' is not assignable to type 'number'
obj.y = 4;
//  ~ Property 'y' does not exist on type '{ x: number; }'
obj.z = 5;
//  ~ Property 'z' does not exist on type '{ x: number; }'
obj.name = 'Pythagoras';
//  ~~~~ Property 'name' does not exist on type '{ x: number; }'
```
----

```ts
const obj: { x: string | number } = { x: 1 };
//    ^? const obj: { x: string | number; }
```
----

```ts
const obj1 = { x: 1, y: 2 };
//    ^? const obj1: { x: number; y: number; }

const obj2 = { x: 1 as const, y: 2 };
//    ^? const obj2: { x: 1; y: number; }

const obj3 = { x: 1, y: 2 } as const;
//    ^? const obj3: { readonly x: 1; readonly y: 2; }
```
----

```ts
const arr1 = [1, 2, 3];
//    ^? const arr1: number[]
const arr2 = [1, 2, 3] as const;
//    ^? const arr2: readonly [1, 2, 3]
```
----

```ts
function tuple<T extends unknown[]>(...elements: T) { return elements; }

const arr3 = tuple(1, 2, 3);
//    ^? const arr3: [number, number, number]
const mix = tuple(4, 'five', true);
//    ^? const mix: [number, string, boolean]
```
----

```ts
const frozenArray = Object.freeze([1, 2, 3]);
//    ^? const frozenArray: readonly number[]
const frozenObj = Object.freeze({x: 1, y: 2});
//    ^? const frozenObj: Readonly<{ x: 1; y: 2; }>
```
----

```ts
type Point = [number, number];
const capitals1 = { ny: [-73.7562, 42.6526], ca: [-121.4944, 38.5816] };
//    ^? const capitals1: { ny: number[]; ca: number[]; }

const capitals2 = {
  ny: [-73.7562, 42.6526], ca: [-121.4944, 38.5816]
} satisfies Record<string, Point>;
capitals2
// ^? const capitals2: { ny: [number, number]; ca: [number, number]; }
```
----

```ts
const capitals3: Record<string, Point> = capitals2;
capitals3.pr;  // undefined at runtime
//        ^? Point
capitals2.pr;
//        ~~ Property 'pr' does not exist on type '{ ny: ...; ca: ...; }'
```
----

```ts
const capitalsBad = {
    ny: [-73.7562, 42.6526, 148],
//  ~~ Type '[number, number, number]' is not assignable to type 'Point'.
    ca: [-121.4944, 38.5816, 26],
//  ~~ Type '[number, number, number]' is not assignable to type 'Point'.
} satisfies Record<string, Point>;
```
---
effective-typescript-main/samples/ch-inference/avoid-inferable.md
---
# Item 18: Avoid Cluttering Your Code with Inferable Types

## Things to Remember

- Avoid writing type annotations when TypeScript can infer the same type.
- Ideal TypeScript code has type annotations in function/method signatures but not on local variables in their bodies.
- Consider using explicit annotations for object literals to enable excess property checking and ensure errors are reported close to where they occur.
- Don't annotate function return types unless the function has multiple returns, is part of a public API, or you want it to return a named type.


## Code Samples

```ts
let x: number = 12;
```
----

```ts
let x = 12;
```
----

```ts
const person: {
  name: string;
  born: {
    where: string;
    when: string;
  };
  died: {
    where: string;
    when: string;
  }
} = {
  name: 'Sojourner Truth',
  born: {
    where: 'Swartekill, NY',
    when: 'c.1797',
  },
  died: {
    where: 'Battle Creek, MI',
    when: 'Nov. 26, 1883'
  }
};
```
----

```ts
const person = {
  name: 'Sojourner Truth',
  born: {
    where: 'Swartekill, NY',
    when: 'c.1797',
  },
  died: {
    where: 'Battle Creek, MI',
    when: 'Nov. 26, 1883'
  }
};
```
----

```ts
function square(nums: number[]) {
  return nums.map(x => x * x);
}
const squares = square([1, 2, 3, 4]);
//    ^? const squares: number[]
```
----

```ts
const axis1: string = 'x';
//    ^? const axis1: string
const axis2 = 'y';
//    ^? const axis2: "y"
```
----

```ts
interface Product {
  id: number;
  name: string;
  price: number;
}

function logProduct(product: Product) {
  const id: number = product.id;
  const name: string = product.name;
  const price: number = product.price;
  console.log(id, name, price);
}
```
----

```ts
interface Product {
  id: string;
  name: string;
  price: number;
}
```
----

```ts
function logProduct(product: Product) {
  const id: number = product.id;
     // ~~ Type 'string' is not assignable to type 'number'
  const name: string = product.name;
  const price: number = product.price;
  console.log(id, name, price);
}
```
----

```ts
function logProduct(product: Product) {
  const {id, name, price} = product;
  console.log(id, name, price);
}
```
----

```ts
function logProduct(product: Product) {
  const {id, name, price}: {id: string; name: string; price: number } = product;
  console.log(id, name, price);
}
```
----

```ts
function parseNumber(str: string, base=10) {
  //                              ^? (parameter) base: number
  // ...
}
```
----

```ts
// Don't do this:
app.get('/health', (request: express.Request, response: express.Response) => {
  response.send('OK');
});

// Do this:
app.get('/health', (request, response) => {
  //                ^? (parameter) request: Request<...>
  response.send('OK');
  // ^? (parameter) response: Response<...>
});
```
----

```ts
const elmo: Product = {
  name: 'Tickle Me Elmo',
  id: '048188 627152',
  price: 28.99,
};
```
----

```ts
const furby = {
  name: 'Furby',
  id: 630509430963,
  price: 35,
};
logProduct(furby);
//         ~~~~~ Argument ... is not assignable to parameter of type 'Product'
//               Types of property 'id' are incompatible
//               Type 'number' is not assignable to type 'string'
```
----

```ts
const furby: Product = {
   name: 'Furby',
   id: 630509430963,
// ~~ Type 'number' is not assignable to type 'string'
   price: 35,
};
logProduct(furby);
```
----

```ts
function getQuote(ticker: string) {
  return fetch(`https://quotes.example.com/?q=${ticker}`)
      .then(response => response.json());
}
```
----

```ts
const cache: {[ticker: string]: number} = {};
function getQuote(ticker: string) {
  if (ticker in cache) {
    return cache[ticker];
  }
  return fetch(`https://quotes.example.com/?q=${ticker}`)
      .then(response => response.json())
      .then(quote => {
        cache[ticker] = quote;
        return quote as number;
      });
}
```
----

```ts
getQuote;
// ^? function getQuote(ticker: string): number | Promise<number>
```
----

```ts
getQuote('MSFT').then(considerBuying);
//               ~~~~ Property 'then' does not exist on type
//                    'number | Promise<number>'
```
----

```ts
const cache: {[ticker: string]: number} = {};
function getQuote(ticker: string): Promise<number> {
  if (ticker in cache) {
    return cache[ticker];
    // ~~~ Type 'number' is not assignable to type 'Promise<number>'
  }
  // ...
}
```
----

```ts
interface Vector2D { x: number; y: number; }
function add(a: Vector2D, b: Vector2D) {
  return { x: a.x + b.x, y: a.y + b.y };
}
```
---
effective-typescript-main/samples/ch-inference/inference-sites.md
---
# Item 28: Use Classes and Currying to Create New Inference Sites

## Things to Remember

- For functions with multiple type parameters, inference is all or nothing: either all type parameters are inferred or all must be specified explicitly.
- To get partial inference, use either classes or currying to create a new inference site.
- Prefer the currying approach if you'd like to create a local type alias.

////
// verifier:reset## Code Samples

```ts
export interface SeedAPI {
  '/seeds': Seed[];
  '/seed/apple': Seed;
  '/seed/strawberry': Seed;
  // ...
}
```
----

```ts
declare function fetchAPI<
  API, Path extends keyof API
>(path: Path): Promise<API[Path]>;
```
----

```ts
fetchAPI<SeedAPI>('/seed/strawberry');
//       ~~~~~~~ Expected 2 type arguments, but got 1.
```
----

```ts
const berry = fetchAPI<SeedAPI, '/seed/strawberry'>('/seed/strawberry');  // ok
//    ^? const berry: Promise<Seed>
```
----

```ts
declare class ApiFetcher<API> {
  fetch<Path extends keyof API>(path: Path): Promise<API[Path]>;
}
```
----

```ts
const fetcher = new ApiFetcher<SeedAPI>();
const berry = await fetcher.fetch('/seed/strawberry'); // OK
//    ^? const berry: Seed

fetcher.fetch('/seed/chicken');
//            ~~~~~~~~~~~~~~~
// Argument of type '"/seed/chicken"' is not assignable to type 'keyof SeedAPI'

const seed: Seed = await fetcher.fetch('/seeds');
//    ~~~~ Seed[] is not assignable to Seed
```
----

```ts
declare function getDate(mon: string, day: number): Date;
getDate('dec', 25);
```
----

```ts
declare function getDate(mon: string): (day: number) => Date;
getDate('dec')(25);
```
----

```ts
declare function fetchAPI<API>():
  <Path extends keyof API>(path: Path) => Promise<API[Path]>;
```
----

```ts
const berry = await fetchAPI<SeedAPI>()('/seed/strawberry'); // OK
//    ^? const berry: Seed

fetchAPI<SeedAPI>()('/seed/chicken');
//                  ~~~~~~~~~~~~~~~
// Argument of type '"/seed/chicken"' is not assignable to type 'keyof SeedAPI'
//
const seed: Seed = await fetchAPI<SeedAPI>()('/seeds');
//    ~~~~ Seed[] is not assignable to Seed
```
----

```ts
const fetchSeedAPI = fetchAPI<SeedAPI>();
const berry = await fetchSeedAPI('/seed/strawberry');
//    ^? const berry: Seed
```
----

```ts
declare function apiFetcher<API>(): {
  fetch<Path extends keyof API>(path: Path): Promise<API[Path]>;
}

const fetcher = apiFetcher<SeedAPI>();
fetcher.fetch('/seed/strawberry');  // ok
```
----

```ts
function fetchAPI<API>() {
  type Routes = keyof API & string;  // local type alias

  return <Path extends Routes>(
    path: Path
  ): Promise<API[Path]> => fetch(path).then(r => r.json());
}
```
---
effective-typescript-main/samples/ch-declarations/export-your-types.md
---
# Item 67: Export All Types That Appear in Public APIs

## Things to Remember

- Export types that appear in any form in any public method. Your users will be able to extract them anyway, so you may as well make it easy for them.

## Code Samples

```ts
interface SecretName {
  first: string;
  last: string;
}

interface SecretSanta {
  name: SecretName;
  gift: string;
}

export function getGift(name: SecretName, gift: string): SecretSanta {
  // ...
}
```
----

```ts
type MySanta = ReturnType<typeof getGift>;
//   ^? type MySanta = SecretSanta
type MyName = Parameters<typeof getGift>[0];
//   ^? type MyName = SecretName
```
---
effective-typescript-main/samples/ch-declarations/use-tsdoc.md
---
# Item 68: Use TSDoc for API Comments

## Things to Remember

- Use JSDoc-/TSDoc-formatted comments to document exported functions, classes, and types. This helps editors surface information for your users when it's most relevant.
- Use `@param`, `@returns`, and Markdown for formatting.
- Avoid including type information in documentation (see pass:[<a href="#jsdoc-repeat">Item 31</a>]).
- Mark deprecated APIs with `@deprecated`.

## Code Samples

```ts
// Generate a greeting. Result is formatted for display.
function greet(name: string, title: string) {
  return `Hello ${title} ${name}`;
}
```
----

```ts
/** Generate a greeting. Result is formatted for display. */
function greetJSDoc(name: string, title: string) {
  return `Hello ${title} ${name}`;
}
```
----

```ts
/**
 * Generate a greeting.
 * @param name Name of the person to greet
 * @param title The person's title
 * @returns A greeting formatted for human consumption.
 */
function greetFullTSDoc(name: string, title: string) {
  return `Hello ${title} ${name}`;
}
```
----

```ts
/** A measurement performed at a time and place. */
interface Measurement {
  /** Where was the measurement made? */
  position: Vector3D;
  /** When was the measurement made? In seconds since epoch. */
  time: number;
  /** Observed momentum */
  momentum: Vector3D;
}
```
---
effective-typescript-main/samples/ch-declarations/mirror-types-for-deps.md
---
# Item 70: Mirror Types to Sever Dependencies

## Things to Remember

- Avoid transitive type dependencies in published npm modules.
- Use structural typing to sever dependencies that are nonessential.
- Don't force JavaScript users to depend on `@types`. Don't force web developers to depend on Node.js.


## Code Samples

```ts
// parse-csv.ts
import {Buffer} from 'node:buffer';

function parseCSV(contents: string | Buffer): {[column: string]: string}[]  {
  if (typeof contents === 'object') {
    // It's a buffer
    return parseCSV(contents.toString('utf8'));
  }
  // ...
}
```
----

```ts
// parse-csv.d.ts
import { Buffer } from 'node:buffer';
export declare function parseCSV(contents: string | Buffer): {
    [column: string]: string;
}[];
```
----

```ts
export interface CsvBuffer {
  toString(encoding?: string): string;
}
export function parseCSV(
  contents: string | CsvBuffer
): {[column: string]: string}[]  {
  // ...
}
```
----

```ts
parseCSV(new Buffer("column1,column2\nval1,val2", "utf-8"));  // OK
```
----

```ts
/** Anything convertible to a string with an encoding, e.g. a Node buffer. */
export interface StringEncodable {
  toString(encoding?: string): string;
}
```
----

```ts
import {Buffer} from 'node:buffer';
import {parseCSV} from './parse-csv';

test('parse CSV in a buffer', () => {
  expect(
    parseCSV(new Buffer("column1,column2\nval1,val2", "utf-8"))
  ).toEqual(
    [{column1: 'val1', column2: 'val2'}]
  );
});
```
---
effective-typescript-main/samples/ch-declarations/three-versions.md
---
# Item 66: Understand the Three Versions Involved in Type Declarations

## Things to Remember

- There are three versions involved in an `@types` dependency: the library version, the `@types` version, and the TypeScript version.
- Recognize the symptoms of different types of version mismatch.
- If you update a library, make sure you update the corresponding `@types`.
- Understand the pros and cons of bundling types versus publishing them on DefinitelyTyped. Prefer bundling types if your library is written in TypeScript, and DefinitelyTyped if it is not.
---
effective-typescript-main/samples/ch-declarations/dev-dependencies.md
---
# Item 65: Put TypeScript and @types in devDependencies

## Things to Remember

- Understand the difference between `dependencies` and `devDependencies` in _package.json_.
- Put TypeScript in your project's `devDependencies`. Don't install TypeScript system-wide.
- Put `@types` dependencies in `devDependencies`, not `dependencies`.
---
effective-typescript-main/samples/ch-declarations/augment-improve.md
---
# Item 71: Use Module Augmentation to Improve Types

## Things to Remember

- Use declaration merging to improve existing APIs or disallow problematic constructs.
- Use `void` or error string returns to "knock out" methods and mark them `@deprecated`.
- Remember that overloads only apply at the type level. Don't make the types diverge from reality.## Code Samples

```ts
declare let apiResponse: string;
```
----

```ts
const response = JSON.parse(apiResponse);
const cacheExpirationTime = response.lastModified + 3600;
//    ^? const cacheExpirationTime: any
```
----

```ts
// declarations/safe-json.d.ts
interface JSON {
  parse(
    text: string,
    reviver?: (this: any, key: string, value: any) => any
  ): unknown;
}
```
----

```ts
const response = JSON.parse(apiResponse);
//    ^? const response: unknown
const cacheExpirationTime = response.lastModified + 3600;
//                          ~~~~~~~~ response is of type 'unknown'.
```
----

```ts
interface ApiResponse {
  lastModified: number;
}
const response = JSON.parse(apiResponse) as ApiResponse;
const cacheExpirationTime = response.lastModified + 3600;  // ok
//    ^? const cacheExpirationTime: number
```
----

```ts
// declarations/safe-response.d.ts
interface Body {
  json(): Promise<unknown>;
}
```
----

```ts
interface SetConstructor {
  new <T>(iterable?: Iterable<T> | null): Set<T>;
}
```
----

```ts
// declarations/ban-set-string-constructor.d.ts:
interface SetConstructor {
  new (str: string): void;
}
```
----

```ts
const s = new Set('abc');
//    ^? const s: void
console.log(s.has('abc'));
//            ~~~ Property 'has' does not exist on type 'void'.
const otherSet: Set<string> = s;
//    ~~~~~~~~ Type 'void' is not assignable to type 'Set<string>'.
```
----

```ts
interface SetConstructor {
  /** @deprecated */
  new (str: string): 'Error! new Set(string) is banned.';
}

const s = new Set('abc');
//    ^? const s: "Error! new Set(string) is banned."
```
---
effective-typescript-main/samples/ch-declarations/this-in-callbacks.md
---
# Item 69: Provide a Type for this in Callbacks if It's Part of Their API

## Things to Remember

- Understand how `this` binding works.
- Provide a type for `this` in callbacks if it's part of your API.
- Avoid dynamic `this` binding in new APIs.

## Code Samples

```ts
class C {
  vals = [1, 2, 3];
  logSquares() {
    for (const val of this.vals) {
      console.log(val ** 2);
    }
  }
}

const c = new C();
c.logSquares();
```
----

```ts
const c = new C();
const method = c.logSquares;
method();
```
----

```ts
const c = new C();
const method = c.logSquares;
method.call(c);  // Logs the squares again
```
----

```ts
document.querySelector('input')?.addEventListener('change', function(e) {
  console.log(this);  // Logs the input element on which the event fired.
});
```
----

```ts
class ResetButton {
  render() {
    return makeButton({text: 'Reset', onClick: this.onClick});
  }
  onClick() {
    alert(`Reset ${this}`);
  }
}
```
----

```ts
class ResetButton {
  constructor() {
    this.onClick = this.onClick.bind(this);
  }
  render() {
    return makeButton({text: 'Reset', onClick: this.onClick});
  }
  onClick() {
    alert(`Reset ${this}`);
  }
}
```
----

```ts
class ResetButton {
  render() {
    return makeButton({text: 'Reset', onClick: this.onClick});
  }
  onClick = () => {
    alert(`Reset ${this}`); // "this" refers to the ResetButton instance.
  }
}
```
----

```js
class ResetButton {
  constructor() {
    this.onClick = () => {
      alert(`Reset ${this}`); // "this" refers to the ResetButton instance.
    };
  }
  render() {
    return makeButton({ text: 'Reset', onClick: this.onClick });
  }
}
```
----

```ts
function addKeyListener(
  el: HTMLElement,
  listener: (this: HTMLElement, e: KeyboardEvent) => void
) {
  el.addEventListener('keydown', e => listener.call(el, e));
}
```
----

```ts
function addKeyListener(
  el: HTMLElement,
  listener: (this: HTMLElement, e: KeyboardEvent) => void
) {
  el.addEventListener('keydown', e => {
    listener(el, e);
    //           ~ Expected 1 arguments, but got 2
  });
}
```
----

```ts
function addKeyListener(
  el: HTMLElement,
  listener: (this: HTMLElement, e: KeyboardEvent) => void
) {
  el.addEventListener('keydown', e => {
    listener(e);
    // ~~~~~~~~ The 'this' context of type 'void' is not assignable
    //          to method's 'this' of type 'HTMLElement'
  });
}
```
----

```ts
declare let el: HTMLElement;
addKeyListener(el, function(e) {
  console.log(this.innerHTML);
  //          ^? this: HTMLElement
});
```
----

```ts
class Foo {
  registerHandler(el: HTMLElement) {
    addKeyListener(el, e => {
      console.log(this.innerHTML);
      //               ~~~~~~~~~ Property 'innerHTML' does not exist on 'Foo'
    });
  }
}
```
---
effective-typescript-main/samples/ch-write-run/model-env.md
---
# Item 76: Create an Accurate Model of Your Environment

## Things to Remember

- Your code runs in a particular environment. TypeScript will do a better job of checking your code if you create an accurate static model of that environment.
- Model global variables and libraries that are loaded onto a web page along with your code.
- Match versions between type declarations and the libraries and runtime environment that you use.
- Use multiple _tsconfig.json_ files and project references to model distinct environments within a single project (for example client and server).

## Code Samples

```ts
// user-info-global.d.ts
interface UserInfo {
  name: string;
  accountId: string;
}
declare global {
  interface Window {
    userInfo: UserInfo;
  }
}
```
----

```ts
import sunrisePath from './images/beautiful-sunrise.jpg';
//                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Cannot find module './images/beautiful-sunrise.jpg' or its type declarations.
```
----

```ts
// webpack-imports.d.ts
declare module '*.jpg' {
  const src: string;
  export default src;
}
```
---
effective-typescript-main/samples/ch-write-run/performance.md
---
# Item 78: Pay Attention to Compiler Performance

## Things to Remember

- There are two forms of TypeScript performance issues: build performance (`tsc`) and editor latency (`tsserver`). Recognize the symptoms of each and direct your optimizations accordingly.
- Keep type checking separate from your build process.
- Remove dead code and dependencies, and be on guard for code bloat in type dependencies. Use a treemap to visualize what TypeScript is compiling.
- Use incremental builds and project references to reduce the work `tsc` does between builds.
- Simplify your types: avoid large unions, use `interface` extension rather than intersection types, and consider annotating function return types.## Code Samples

```ts
// hello.ts
console.log('Hello World!');
```
----

```ts
function foo() {}
//       ~~~ 'foo' is declared but its value is never read.

export function bar() {}
```
----

```ts
// src/fib.ts
export function fib(n: number): number {
  if (n < 2) {
    return n;
  }
  return fib(n - 1) + fib(n - 2);
}
```
----

```ts
// test/fib.test.ts
import {fib} from '../src/fib';

describe('fib', () => {
  it('should handle base cases', () => {
    expect(fib(0)).toEqual(0);
    expect(fib(1)).toEqual(1);
  })

  it('should handle larger numbers', () => {
    expect(fib(2)).toEqual(1);
    expect(fib(3)).toEqual(2);
    expect(fib(4)).toEqual(3);
    expect(fib(5)).toEqual(5);
    expect(fib(16)).toEqual(987);
  });
});
```
----

```ts
type Digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';
type Year = `2${Digit}${Digit}${Digit}`;
const validYear: Year = '2024';
const invalidYear: Year = '1999';
//    ~~~~~~~~~~~ Type '"1999"' is not assignable to type
//                '"2000" | "2001" | "2002" | ... 996 more ... | "2999"'.
```
---
effective-typescript-main/samples/ch-write-run/runtime-types.md
---
# Item 74: Know How to Reconstruct Types at Runtime

## Things to Remember

- TypeScript types are erased before your code is run. You can't access them at runtime without additional tooling.
- Know your options for runtime types: using a distinct runtime type system (such as Zod), generating TypeScript types from values (`json-schema-to-typescript`), and generating values from your TypeScript types (`typescript-json-schema`).
- If you have another specification for your types (e.g., a schema), use that as the source of truth.
- If you need to reference external TypeScript types, use `typescript-json-schema` or an equivalent.
- Otherwise, weigh whether you prefer another build step or another system for specifying types.

## Code Samples

```ts
interface CreateComment {
  postId: string;
  title: string;
  body: string;
}
```
----

```ts
app.post('/comment', (request, response) => {
  const {body} = request;
  if (
    !body ||
    typeof body !== 'object' ||
    Object.keys(body).length !== 3 ||
    !('postId' in body) || typeof body.postId !== 'string' ||
    !('title' in body) || typeof body.title !== 'string' ||
    !('body' in body) || typeof body.body !== 'string'
  ) {
    return response.status(400).send('Invalid request');
  }
  const comment = body as CreateComment;
  // ... application validation and logic ...
  return response.status(200).send('ok');
});
```
----

```ts
const val = { postId: '123', title: 'First', body: 'That is all'};
type ValType = typeof val;
//   ^? type ValType = { postId: string; title: string; body: string; }
```
----

```ts
import { z } from 'zod';

// runtime value for type validation
const createCommentSchema = z.object({
  postId: z.string(),
  title: z.string(),
  body: z.string(),
});

// static type
type CreateComment = z.infer<typeof createCommentSchema>;
//   ^? type CreateComment = { postId: string; title: string; body: string; }

app.post('/comment', (request, response) => {
  const {body} = request;
  try {
    const comment = createCommentSchema.parse(body);
    //    ^? const comment: { postId: string; title: string; body: string; }
    // ... application validation and logic ...
    return response.status(200).send('ok');
  } catch (e) {
    return response.status(400).send('Invalid request');
  }
});
```
----

```ts
// api.ts
export interface CreateComment {
  postId: string;
  title: string;
  body: string;
}
```
----

```ts
import Ajv from 'ajv';

import apiSchema from './api.schema.json';
import {CreateComment} from './api';

const ajv = new Ajv();

app.post('/comment', (request, response) => {
  const {body} = request;
  if (!ajv.validate(apiSchema.definitions.CreateComment, body)) {
    return response.status(400).send('Invalid request');
  }
  const comment = body as CreateComment;
  // ... application validation and logic ...
  return response.status(200).send('ok');
});
```
---
effective-typescript-main/samples/ch-write-run/avoid-non-ecma.md
---
# Item 72: Prefer ECMAScript Features to TypeScript Features

## Things to Remember

- By and large, you can convert TypeScript to JavaScript by removing all the types from your code.
- Enums, parameter properties, triple-slash imports, experimental decorators, and member visibility modifiers are historical exceptions to this rule.
- To keep TypeScript’s role in your codebase as clear as possible and to avoid future compatibility issues, avoid nonstandard features.

## Code Samples

```ts
enum Flavor {
  Vanilla = 0,
  Chocolate = 1,
  Strawberry = 2,
}

let flavor = Flavor.Chocolate;
//  ^? let flavor: Flavor

Flavor  // Autocomplete shows: Vanilla, Chocolate, Strawberry
Flavor[0]  // Value is "Vanilla"
```
----

```ts
enum Flavor {
  Vanilla = 'vanilla',
  Chocolate = 'chocolate',
  Strawberry = 'strawberry',
}

let favoriteFlavor = Flavor.Chocolate;  // Type is Flavor
favoriteFlavor = 'strawberry';
// ~~~~~~~~~~~ Type '"strawberry"' is not assignable to type 'Flavor'
```
----

```ts
function scoop(flavor: Flavor) { /* ... */ }
```
----

```ts
scoop('vanilla');
//    ~~~~~~~~~ '"vanilla"' is not assignable to parameter of type 'Flavor'

import {Flavor} from 'ice-cream';
scoop(Flavor.Vanilla);  // OK
```
----

```ts
type Flavor = 'vanilla' | 'chocolate' | 'strawberry';

let favoriteFlavor: Flavor = 'chocolate';  // OK
favoriteFlavor = 'americone dream';
// ~~~~~~~~~~~ Type '"americone dream"' is not assignable to type 'Flavor'
```
----

```ts
class Person {
  name: string;
  constructor(name: string) {
    this.name = name;
  }
}
```
----

```ts
class Person {
  constructor(public name: string) {}
}
```
----

```ts
class Person {
  first: string;
  last: string;
  constructor(public name: string) {
    [this.first, this.last] = name.split(' ');
  }
}
```
----

```ts
class PersonClass {
  constructor(public name: string) {}
}
const p: PersonClass = { name: 'Jed Bartlet' };  // OK

interface Person {
  name: string;
}
const jed: Person = new PersonClass('Jed Bartlet');  // also OK
```
----

```ts
// other.ts
namespace foo {
  export function bar() {}
}
```
----

```ts
// index.ts
/// <reference path="other.ts"/>
foo.bar();
```
----

```ts
class Greeter {
  greeting: string;
  constructor(message: string) {
    this.greeting = message;
  }
  @logged  // <-- this is the decorator
  greet() {
    return `Hello, ${this.greeting}`;
  }
}

function logged(originalFn: any, context: ClassMethodDecoratorContext) {
  return function(this: any, ...args: any[]) {
    console.log(`Calling ${String(context.name)}`);
    return originalFn.call(this, ...args);
  };
}

console.log(new Greeter('Dave').greet());
// Logs:
// Calling greet
// Hello, Dave
```
----

```ts
class Diary {
  private secret = 'cheated on my English test';
}

const diary = new Diary();
diary.secret
//    ~~~~~~ Property 'secret' is private and only accessible within ... 'Diary'
```
----

```ts
const diary = new Diary();
(diary as any).secret  // OK

console.log(Object.entries(diary));
// logs [["secret", "cheated on my English test"]]
```
----

```ts
class PasswordChecker {
  #passwordHash: number;

  constructor(passwordHash: number) {
    this.#passwordHash = passwordHash;
  }

  checkPassword(password: string) {
    return hash(password) === this.#passwordHash;
  }
}

const checker = new PasswordChecker(hash('s3cret'));
checker.#passwordHash
//      ~~~~~~~~~~~~~ Property '#passwordHash' is not accessible outside class
//                    'PasswordChecker' because it has a private identifier.
checker.checkPassword('secret');  // Returns false
checker.checkPassword('s3cret');  // Returns true
```
---
effective-typescript-main/samples/ch-write-run/source-maps-debug.md
---
# Item 73: Use Source Maps to Debug TypeScript

## Things to Remember

- Don't debug generated JavaScript. Use source maps to debug your TypeScript code at runtime.
- Make sure that your source maps are mapped all the way through to the code that you run.
- Know how to debug Node.js code written in TypeScript.
- Depending on your settings, your source maps might contain an inline copy of your original code. Don't publish them unless you know what you're doing!

## Code Samples

```ts
// index.ts
function addCounter(el: HTMLElement) {
  let clickCount = 0;
  const button = document.createElement('button');
  button.textContent = 'Click me';
  button.addEventListener('click', () => {
    clickCount++;
    button.textContent = `Click me (${clickCount})`;
  });
  el.appendChild(button);
}

addCounter(document.body);
```
----

```ts
// index.ts
function addCounter(el: HTMLElement) {
  let clickCount = 0;
  const triviaEl = document.createElement('p');
  const button = document.createElement('button');
  button.textContent = 'Click me';
  button.addEventListener('click', async () => {
    clickCount++;
    const response = await fetch(`http://numbersapi.com/${clickCount}`);
    const trivia = await response.text();
    triviaEl.textContent = trivia;
    button.textContent = `Click me (${clickCount})`;
  });
  el.appendChild(triviaEl);
  el.appendChild(button);
}
```
----

```ts
// bedtime.ts
async function sleep(ms: number) {
  return new Promise<void>(resolve => setTimeout(resolve, ms));
}

async function main() {
  console.log('Good night!');
  await sleep(1000);
  console.log('Morning already!?');
}

main();
```
---
effective-typescript-main/samples/ch-write-run/understand-the-dom.md
---
# Item 75: Understand the DOM Hierarchy

## Things to Remember

- The DOM has a type hierarchy that you can usually ignore while writing JavaScript. But these types become more important in TypeScript. Understanding them will help you write TypeScript for the browser.
- Know the differences between `Node`, `Element`, `HTMLElement`, and `EventTarget`, as well as those between `Event` and `MouseEvent`.
- Either use a specific enough type for DOM elements and Events in your code or give TypeScript the context to infer it.

## Code Samples

```ts
function handleDrag(eDown: Event) {
  const targetEl = eDown.currentTarget;
  targetEl.classList.add('dragging');
  // ~~~~~           'targetEl' is possibly 'null'
  //       ~~~~~~~~~ Property 'classList' does not exist on type 'EventTarget'
  const dragStart = [
     eDown.clientX, eDown.clientY
     //    ~~~~~~~        ~~~~~~~ Property '...' does not exist on 'Event'
  ];
  const handleUp = (eUp: Event) => {
    targetEl.classList.remove('dragging');
    // ~~~~~           'targetEl' is possibly 'null'
    //       ~~~~~~~~~ Property 'classList' does not exist on type 'EventTarget'
    targetEl.removeEventListener('mouseup', handleUp);
    // ~~~~~ 'targetEl' is possibly 'null'
    const dragEnd = [
      eUp.clientX, eUp.clientY
      //  ~~~~~~~      ~~~~~~~   Property '...' does not exist on 'Event'
    ];
    console.log('dx, dy = ', [0, 1].map(i => dragEnd[i] - dragStart[i]));
  }
  targetEl.addEventListener('mouseup', handleUp);
  // ~~~~~ 'targetEl' is possibly 'null'
}

const surfaceEl = document.getElementById('surface');
surfaceEl.addEventListener('mousedown', handleDrag);
// ~~~~~~ 'surfaceEl' is possibly 'null'
```
----

```ts
function handleDrag(eDown: Event) {
  const targetEl = eDown.currentTarget;
  targetEl.classList.add('dragging');
  // ~~~~~           'targetEl' is possibly 'null'
  //       ~~~~~~~~~ Property 'classList' does not exist on type 'EventTarget'
  // ...
}
```
----

```ts
const p = document.getElementsByTagName('p')[0];
//    ^? const p: HTMLParagraphElement
const button = document.createElement('button');
//    ^? const button: HTMLButtonElement
const div = document.querySelector('div');
//    ^? const div: HTMLDivElement | null
```
----

```ts
const div = document.getElementById('my-div');
//    ^? const div: HTMLElement | null
```
----

```ts
document.getElementById('my-div') as HTMLDivElement;
```
----

```ts
const div = document.getElementById('my-div');
if (div instanceof HTMLDivElement) {
  console.log(div);
  //          ^? const div: HTMLDivElement
}
```
----

```ts
const div = document.getElementById('my-div')!;
//    ^? const div: HTMLElement
```
----

```ts
function handleDrag(eDown: Event) {
  // ...
  const dragStart = [
     eDown.clientX, eDown.clientY
     //    ~~~~~~~        ~~~~~~~ Property '...' does not exist on 'Event'
  ];
  // ...
}
```
----

```ts
function addDragHandler(el: HTMLElement) {
  el.addEventListener('mousedown', eDown => {
    const dragStart = [eDown.clientX, eDown.clientY];
    const handleUp = (eUp: MouseEvent) => {
      el.classList.remove('dragging');
      el.removeEventListener('mouseup', handleUp);
      const dragEnd = [eUp.clientX, eUp.clientY];
      console.log('dx, dy = ', [0, 1].map(i => dragEnd[i] - dragStart[i]));
    }
    el.addEventListener('mouseup', handleUp);
  });
}

const surfaceEl = document.getElementById('surface');
if (surfaceEl) {
  addDragHandler(surfaceEl);
}
```
---
effective-typescript-main/samples/ch-write-run/types-or-tests.md
---
# Item 77: Understand the Relationship Between Type Checking and Unit Testing

## Things to Remember

- Type checking and unit testing are different, complementary techniques for demonstrating program correctness. You want both.
- Unit tests demonstrate correct behavior on particular inputs, while type checking eliminates whole classes of incorrect behaviors.
- Rely on the type checker to check types. Write unit tests for behaviors that can't be checked with types.
- Avoid testing inputs that would be type errors unless there are concerns about security or data corruption.

## Code Samples

```ts
test('add', () => {
  expect(add(0, 0)).toEqual(0);
  expect(add(123, 456)).toEqual(579);
  expect(add(-100, 90)).toEqual(-10);
});
```
----

```ts
function add(a: number, b: number): number {
  if (isNaN(a) || isNaN(b)) {
    return 'Not a number!';
    // ~~~ Type 'string' is not assignable to type 'number'.
  }
  return (a|0) + (b|0);
}
```
----

```ts
function add(a: number, b: number): number {
  return a - b; // oops!
}
```
----

```ts
test('out-of-domain add', () => {
  expect(add(null, null)).toEqual(0);
  //         ~~~~ Type 'null' is not assignable to parameter of type 'number'.
  expect(add(null, 12)).toEqual(12);
  //         ~~~~ Type 'null' is not assignable to parameter of type 'number'.
  expect(add(undefined, null)).toBe(NaN);
  //         ~~~~~~~~~ Type 'undefined' is not assignable to parameter of ...
  expect(add('ab', 'cd')).toEqual('abcd');
  //         ~~~~ Type 'string' is not assignable to parameter of type 'number'.
});
```
----

```ts
interface User {
  id: string;
  name: string;
  memberSince: string;
}

declare function updateUserById(
  id: string,
  update: Partial<Omit<User, 'id'>> & {id?: never}
): Promise<User>;
```
----

```ts
test('invalid update', () => {
  // @ts-expect-error Can't call updateUserById to update an ID.
  expect(() => updateUserById('123', {id: '234'})).toReject();
});
```
---
effective-typescript-main/samples/ch-any/hide-unsafe-casts.md
---
# Item 45: Hide Unsafe Type Assertions in Well-Typed Functions

## Things to Remember

- Sometimes unsafe type assertions and `any` types are necessary or expedient. When you need to use one, hide it inside a function with a correct signature.
- Don't compromise a function's type signature to fix type errors in the implementation.
- Make sure you explain why your type assertions are valid, and unit test your code thoroughly.

## Code Samples

```ts
interface MountainPeak {
  name: string;
  continent: string;
  elevationMeters: number;
  firstAscentYear: number;
}

async function checkedFetchJSON(url: string): Promise<unknown> {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Unable to fetch! ${response.statusText}`);
  }
  return response.json();
}

export async function fetchPeak(peakId: string): Promise<MountainPeak> {
  return checkedFetchJSON(`/api/mountain-peaks/${peakId}`);
// ~~~~~ Type 'unknown' is not assignable to type 'MountainPeak'.
}
```
----

```ts
export async function fetchPeak(peakId: string): Promise<unknown> {
  return checkedFetchJSON(`/api/mountain-peaks/${peakId}`);  // ok
}
```
----

```ts
const sevenPeaks = [
  'aconcagua', 'denali', 'elbrus', 'everest', 'kilimanjaro', 'vinson', 'wilhelm'
];
async function getPeaksByHeight(): Promise<MountainPeak[]> {
  const peaks = await Promise.all(sevenPeaks.map(fetchPeak));
  return peaks.toSorted(
  // ~~~ Type 'unknown' is not assignable to type 'MountainPeak'.
    (a, b) => b.elevationMeters - a.elevationMeters
    //        ~                   ~ 'b' and 'a' are of type 'unknown'
  );
}
```
----

```ts
async function getPeaksByDate(): Promise<MountainPeak[]> {
  const peaks = await Promise.all(sevenPeaks.map(fetchPeak)) as MountainPeak[];
  return peaks.toSorted((a, b) => b.firstAscentYear - a.firstAscentYear);
}
```
----

```ts
export async function fetchPeak(peakId: string): Promise<MountainPeak> {
  return checkedFetchJSON(
    `/api/mountain-peaks/${peakId}`,
  ) as Promise<MountainPeak>;
}
```
----

```ts
async function getPeaksByContinent(): Promise<MountainPeak[]> {
  const peaks = await Promise.all(sevenPeaks.map(fetchPeak));  // no assertion!
  return peaks.toSorted((a, b) => a.continent.localeCompare(b.continent));
}
```
----

```ts
export async function fetchPeak(peakId: string): Promise<MountainPeak> {
  const maybePeak = checkedFetchJSON(`/api/mountain-peaks/${peakId}`);
  if (
    !maybePeak ||
    typeof maybePeak !== 'object' ||
    !('firstAscentYear' in maybePeak)
  ) {
    throw new Error(`Invalid mountain peak: ${JSON.stringify(maybePeak)}`);
  }
  return checkedFetchJSON(
    `/api/mountain-peaks/${peakId}`,
  ) as Promise<MountainPeak>;
}
```
----

```ts
export async function fetchPeak(peakId: string): Promise<MountainPeak>;
export async function fetchPeak(peakId: string): Promise<unknown> {
  return checkedFetchJSON(`/api/mountain-peaks/${peakId}`);  // OK
}

const denali = fetchPeak('denali');
//    ^? const denali: Promise<MountainPeak>
```
----

```ts
function shallowObjectEqual(a: object, b: object): boolean {
  for (const [k, aVal] of Object.entries(a)) {
    if (!(k in b) || aVal !== b[k]) {
      //                      ~~~~ Element implicitly has an 'any' type
      //                           because type '{}' has no index signature
      return false;
    }
  }
  return Object.keys(a).length === Object.keys(b).length;
}
```
----

```ts
function shallowObjectEqualBad(a: object, b: any): boolean {
  for (const [k, aVal] of Object.entries(a)) {
    if (!(k in b) || aVal !== b[k]) {  // ok
      return false;
    }
  }
  return Object.keys(a).length === Object.keys(b).length;
}
```
----

```ts
shallowObjectEqual({x: 1}, null)
//                         ~~~~ Type 'null' is not assignable to type 'object'.
shallowObjectEqualBad({x: 1}, null);  // ok, throws at runtime
```
----

```ts
function shallowObjectEqualGood(a: object, b: object): boolean {
  for (const [k, aVal] of Object.entries(a)) {
    if (!(k in b) || aVal !== (b as any)[k]) {
      // `(b as any)[k]` is OK because we've just checked `k in b`
      return false;
    }
  }
  return Object.keys(a).length === Object.keys(b).length;
}
```
---
effective-typescript-main/samples/ch-any/narrowest-any.md
---
# Item 43: Use the Narrowest Possible Scope for any Types

## Things to Remember

- Make your uses of `any` as narrowly scoped as possible to avoid undesired loss of type safety elsewhere in your code.
- Never return an `any` type from a function. This will silently lead to the loss of type safety for code that calls the function.
- Use `as any` on individual properties of a larger object instead of the whole object.

## Code Samples

```ts
declare function getPizza(): Pizza;
function eatSalad(salad: Salad) { /* ... */ }

function eatDinner() {
  const pizza = getPizza();
  eatSalad(pizza);
  //       ~~~~~
  // Argument of type 'Pizza' is not assignable to parameter of type 'Salad'
  pizza.slice();
}
```
----

```ts
function eatDinner1() {
  const pizza: any = getPizza();  // Don't do this
  eatSalad(pizza);  // ok
  pizza.slice();  // This call is unchecked!
}

function eatDinner2() {
  const pizza = getPizza();
  eatSalad(pizza as any);  // This is preferable
  pizza.slice();  // this is safe
}
```
----

```ts
function eatDinner1() {
  const pizza: any = getPizza();
  eatSalad(pizza);
  pizza.slice();
  return pizza;  // unsafe pizza!
}

function spiceItUp() {
  const pizza = eatDinner1();
  //    ^? const pizza: any
  pizza.addRedPepperFlakes();  // This call is also unchecked!
}
```
----

```ts
function eatDinner1() {
  const pizza = getPizza();
  // @ts-ignore
  eatSalad(pizza);
  pizza.slice();
}

function eatDinner2() {
  const pizza = getPizza();
  // @ts-expect-error
  eatSalad(pizza);
  pizza.slice();
}
```
----

```ts
const config: Config = {
  a: 1,
  b: 2,
  c: {
    key: value
 // ~~~ Property ... missing in type 'Bar' but required in type 'Foo'
  }
};
```
----

```ts
const config: Config = {
  a: 1,
  b: 2,
  c: {
    key: value
  }
} as any;  // Don't do this!
```
----

```ts
const config: Config = {
  a: 1,
  b: 2,  // These properties are still checked
  c: {
    key: value as any
  }
};
```
---
effective-typescript-main/samples/ch-any/specific-any.md
---
# Item 44: Prefer More Precise Variants of any to Plain any

## Things to Remember

- When you use `any`, think about whether any JavaScript value is truly permissible.
- Prefer more precise forms of `any` such as `any[]` or `{[id: string]: any}` or `() => any` if they more accurately model your data.

// TODO: I don't love these examples since they could all be replaced with `unknown[]`.

## Code Samples

```ts
function getLengthBad(array: any) {  // Don't do this!
  return array.length;
}

function getLength(array: any[]) {  // This is better
  return array.length;
}
```
----

```ts
getLengthBad(/123/);  // No error, returns undefined
getLength(/123/);
//        ~~~~~
// Argument of type 'RegExp' is not assignable to parameter of type 'any[]'.

getLengthBad(null);  // No error, throws at runtime
getLength(null);
//        ~~~~
// Argument of type 'null' is not assignable to parameter of type 'any[]'.
```
----

```ts
function hasAKeyThatEndsWithZ(o: Record<string, any>) {
  for (const key in o) {
    if (key.endsWith('z')) {
      console.log(key, o[key]);
      return true;
    }
  }
  return false;
}
```
----

```ts
function hasAKeyThatEndsWithZ(o: object) {
  for (const key in o) {
    if (key.endsWith('z')) {
      console.log(key, o[key]);
      //               ~~~~~~ Element implicitly has an 'any' type
      //                      because type '{}' has no index signature
      return true;
    }
  }
  return false;
}
```
----

```ts
type Fn0 = () => any;  // any function callable with no params
type Fn1 = (arg: any) => any;  // With one param
type FnN = (...args: any[]) => any;  // With any number of params
                                     // same as "Function" type
```
----

```ts
const numArgsBad = (...args: any) => args.length;
//    ^? const numArgsBad: (...args: any) => any
const numArgsBetter = (...args: any[]) => args.length;
//    ^? const numArgsBetter: (...args: any[]) => number
```
---
effective-typescript-main/samples/ch-any/type-safe-monkey.md
---
# Item 47: Prefer Type-Safe Approaches to Monkey Patching

## Things to Remember

- Prefer structured code to storing data in globals or on the DOM.
- If you must store data on built-in types, use one of the type-safe approaches (augmentation or asserting a custom interface).
- Understand the scoping issues of augmentations. Include `undefined` if that's a possibility at runtime.

## Code Samples

```ts
document.monkey = 'Tamarin';
//       ~~~~~~ Property 'monkey' does not exist on type 'Document'
```
----

```ts
(document as any).monkey = 'Tamarin';  // OK
```
----

```ts
(document as any).monky = 'Tamarin';  // Also OK, misspelled
(document as any).monkey = /Tamarin/;  // Also OK, wrong type
```
----

```ts
interface User {
  name: string;
}

document.addEventListener("DOMContentLoaded", async () => {
  const response = await fetch('/api/users/current-user');
  const user = (await response.json()) as User;
  window.user = user;
  //     ~~~~ Property 'user' does not exist
  //          on type 'Window & typeof globalThis'.
});

// ... elsewhere ...
export function greetUser() {
  alert(`Hello ${window.user.name}!`);
  //                    ~~~~ Property 'user' does not exist on type Window...
}
```
----

```ts
declare global {
  interface Window {
    /** The currently logged-in user */
    user: User;
  }
}
```
----

```ts
document.addEventListener("DOMContentLoaded", async () => {
  const response = await fetch('/api/users/current-user');
  const user = (await response.json()) as User;
  window.user = user;  // OK
});

// ... elsewhere ...
export function greetUser() {
  alert(`Hello ${window.user.name}!`);  // OK
}
```
----

```ts
declare global {
  interface Window {
    /** The currently logged-in user */
    user: User | undefined;
  }
}

// ...
export function greetUser() {
  alert(`Hello ${window.user.name}!`);
  //             ~~~~~~~~~~~ 'window.user' is possibly 'undefined'.
}
```
----

```ts
type MyWindow = (typeof window) & {
  /** The currently logged-in user */
  user: User | undefined;
}

document.addEventListener("DOMContentLoaded", async () => {
  const response = await fetch('/api/users/current-user');
  const user = (await response.json()) as User;
  (window as MyWindow).user = user;  // OK
});

// ...
export function greetUser() {
  alert(`Hello ${(window as MyWindow).user.name}!`);
  //             ~~~~~~~~~~~~~~~~~~~~~~~~~ Object is possibly 'undefined'.
}
```
---
effective-typescript-main/samples/ch-any/never-unknown.md
---
# Item 46: Use unknown Instead of any for Values with an Unknown Type

## Things to Remember

- The `unknown` type is a type-safe alternative to `any`. Use it when you know you have a value but do not know or do not care what its type is.
- Use `unknown` to force your users to use a type assertion or other form of narrowing.
- Avoid return-only type parameters, which can create a false sense of security.
- Understand the difference between `{}`, `object`, and `unknown`.

////## Code Samples

```ts
function parseYAML(yaml: string): any {
  // ...
}
```
----

```ts
interface Book {
  name: string;
  author: string;
}
const book: Book = parseYAML(`
  name: Wuthering Heights
  author: Emily Brontë
`);
```
----

```ts
const book = parseYAML(`
  name: Jane Eyre
  author: Charlotte Brontë
`);
console.log(book.title);  // No error, logs "undefined" at runtime
book('read');  // No error, throws "book is not a function" at runtime
```
----

```ts
function safeParseYAML(yaml: string): unknown {
  return parseYAML(yaml);
}
const book = safeParseYAML(`
  name: The Tenant of Wildfell Hall
  author: Anne Brontë
`);
console.log(book.title);
//          ~~~~ 'book' is of type 'unknown'
book("read");
// Error: 'book' is of type 'unknown'
```
----

```ts
const book = safeParseYAML(`
  name: Villette
  author: Charlotte Brontë
`) as Book;
console.log(book.title);
//               ~~~~~ Property 'title' does not exist on type 'Book'
book('read');
// Error: This expression is not callable
```
----

```ts
interface Feature {
  id?: string | number;
  geometry: Geometry;
  properties: unknown;
}
```
----

```ts
function isSmallArray(arr: readonly unknown[]): boolean {
  return arr.length < 10;
}
```
----

```ts
function processValue(value: unknown) {
  if (value instanceof Date) {
    value
    // ^? (parameter) value: Date
  }
}
```
----

```ts
function isBook(value: unknown): value is Book {
  return (
      typeof(value) === 'object' && value !== null &&
      'name' in value && 'author' in value
  );
}
function processValue(value: unknown) {
  if (isBook(value)) {
    value;
    // ^? (parameter) value: Book
  }
}
```
----

```ts
function safeParseYAML<T>(yaml: string): T {
  return parseYAML(yaml);
}
```
----

```ts
declare const foo: Foo;
let barAny = foo as any as Bar;
let barUnk = foo as unknown as Bar;
```
---
effective-typescript-main/samples/ch-any/unsoundness.md
---
# Item 48: Avoid Soundness Traps

## Things to Remember

- "Unsoundness" is when a symbol's value at runtime diverges from its static type. It can lead to crashes and other bad behavior without type errors.
- Be aware of some of the common ways that unsoundness can arise: `any` types, type assertions (`as`, `is`), object and array lookups, and inaccurate type definitions.
- Avoid mutating function parameters as this can lead to unsoundness. Mark them as read-only if you don't intend to mutate them.
- Make sure child classes match their parent's method declarations.
- Be aware of how optional properties can lead to unsound types.

## Code Samples

```ts
const x = Math.random();
//    ^? const x: number
```
----

```ts
const xs = [0, 1, 2];
//    ^? const xs: number[]
const x = xs[3];
//    ^? const x: number
```
----

```ts
console.log(x.toFixed(1));
```
----

```ts
function logNumber(x: number) {
  console.log(x.toFixed(1));  // x is a string at runtime
  //          ^? (parameter) x: number
}
const num: any = 'forty two';
logNumber(num);  // no error
```
----

```ts
function logNumber(x: number) {
  console.log(x.toFixed(1));
}
const hour = (new Date()).getHours() || null;
//    ^? const hour: number | null
logNumber(hour);
//        ~~~~ ... Type 'null' is not assignable to type 'number'.
logNumber(hour as number);  // type checks, but might blow up at runtime
```
----

```ts
if (hour !== null) {
  logNumber(hour);  // ok
  //        ^? const hour: number
}
```
----

```ts
type IdToName = { [id: string]: string };
const ids: IdToName = {'007': 'James Bond'};
const agent = ids['008'];  // undefined at runtime.
//    ^? const agent: string
```
----

```ts
const xs = [1, 2, 3];
alert(xs[3].toFixed(1));  // invalid code
//    ~~~~~ Object is possibly 'undefined'.
alert(xs[2].toFixed(1));  // valid code
//    ~~~~~ Object is possibly 'undefined'.
```
----

```ts
const xs = [1, 2, 3];
for (const x of xs) {
  console.log(x.toFixed(1));  // OK
}
const squares = xs.map(x => x * x);  // also OK
```
----

```ts
const xs: (number | undefined)[] = [1, 2, 3];
alert(xs[3].toFixed(1));
//    ~~~~~ Object is possibly 'undefined'.

type IdToName = { [id: string]: string | undefined };
const ids: IdToName = {'007': 'James Bond'};
const agent = ids['008'];
//    ^? const agent: string | undefined
alert(agent.toUpperCase());
//    ~~~~~ 'agent' is possibly 'undefined'.
```
----

```ts
'foo'.replace(/f(.)/, (fullMatch, group1, offset, fullString, namedGroups) => {
  console.log(fullMatch);  // "fo"
  console.log(group1);  // "o"
  console.log(offset);  // 0
  console.log(fullString); // "foo"
  console.log(namedGroups);  // undefined
  return fullMatch;
});
```
----

```ts
declare function f(): number | string;
const f1: () => number | string | boolean = f;  // OK
const f2: () => number = f;
//    ~~ Type '() => string | number' is not assignable to type '() => number'.
//         Type 'string | number' is not assignable to type 'number'.
```
----

```ts
declare function f(x: number | string): void;
const f1: (x: number | string | boolean) => void = f;
//    ~~
// Type 'string | number | boolean' is not assignable to type 'string | number'.
const f2: (x: number) => void = f;  // OK
```
----

```ts
class Parent {
  foo(x: number | string) {}
  bar(x: number) {}
}
class Child extends Parent {
  foo(x: number) {}  // OK
  bar(x: number | string) {}  // OK
}
```
----

```ts
class FooChild extends Parent  {
  foo(x: number) {
    console.log(x.toFixed());
  }
}
const p: Parent = new FooChild();
p.foo('string');  // No type error, crashes at runtime
```
----

```ts
function addFoxOrHen(animals: Animal[]) {
  animals.push(Math.random() > 0.5 ? new Fox() : new Hen());
}

const henhouse: Hen[] = [new Hen()];
addFoxOrHen(henhouse); // oh no, a fox in the henhouse!
```
----

```ts
function addFoxOrHen(animals: readonly Animal[]) {
  animals.push(Math.random() > 0.5 ? new Fox() : new Hen());
  //      ~~~~ Property 'push' does not exist on type 'readonly Animal[]'.
}
```
----

```ts
function foxOrHen(): Animal {
  return Math.random() > 0.5 ? new Fox() : new Hen();
}

const henhouse: Hen[] = [new Hen(), foxOrHen()];
//                                  ~~~~~~~~~~ error, yay! Chickens are safe.
// Type 'Animal' is missing the following properties from type 'Hen': ...
```
----

```ts
interface FunFact {
  fact: string;
  author?: string;
}

function processFact(fact: FunFact, processor: (fact: FunFact) => void) {
  if (fact.author) {
    processor(fact);
    console.log(fact.author.blink());  // ok
    //               ^? (property) FunFact.author?: string
  }
}
```
----

```ts
processFact(
  {fact: 'Peanuts are not actually nuts', author: 'Botanists'},
  f => delete f.author
);
// Type checks, but throws `Cannot read property 'blink' of undefined`.
```
----

```ts
interface Person {
  name: string;
}
interface PossiblyAgedPerson extends Person {
  age?: number;
}
const p1 = { name: "Serena", age: "42 years" };
const p2: Person = p1;
const p3: PossiblyAgedPerson = p2;
console.log(`${p3.name} is ${p3.age?.toFixed(1)} years old.`);
```
---
effective-typescript-main/samples/ch-any/type-percentage.md
---
# Item 49: Track Your Type Coverage to Prevent Regressions in Type Safety

## Things to Remember

- Even with `noImplicitAny` set, `any` types can make their way into your code either through explicit ++any++s or third-party type declarations (`@types`).
- Consider tracking how well-typed your program is using a tool like `type-coverage`. This will encourage you to revisit decisions about using `any` and increase type safety over time.## Code Samples

```ts
function getColumnInfo(name: string): any {
  return utils.buildColumnInfo(appState.dataSchema, name);  // Returns any
}
```
----

```ts
declare module 'my-module';
```
----

```ts
import {someMethod, someSymbol} from 'my-module';  // OK

const pt1 = { x: 1, y: 2 };
//    ^? const pt1: { x: number; y: number; }
const pt2 = someMethod(pt1, someSymbol);  // OK
//    ^? const pt2: any
```
---
effective-typescript-main/samples/ch-generics/type-display.md
---
# Item 56: Pay Attention to How Types Display

## Things to Remember

- There are many valid ways to display the same type. Some are clearer than others.
- TypeScript gives you some tools to control how types display, notably the `Resolve` generic. Make judicious use of this to clarify type display and hide implementation details.
- Consider handling important special cases of generic types to improve type display.
- Write tests for your generic types and their display to avoid regressions.

## Code Samples

```ts
type T123 = '1' | '2' | '3';
//   ^? type T123 = "1" | "2" | "3"
```
----

```ts
type T21 = '2' | '1';
//   ^? type T21 = "2" | "1"

type T123 = '1' | '2' | '3';
//   ^? type T123 = "2" | "1" | "3"
```
----

```ts
type PartiallyPartial<T, K extends keyof T> =
  Partial<Pick<T, K>> & Omit<T, K>;
```
----

```ts
interface BlogComment {
  commentId: number;
  title: string;
  content: string;
}

type PartComment = PartiallyPartial<BlogComment, 'title'>;
//   ^? type PartComment =
//          Partial<Pick<BlogComment, "title">> &
//          Omit<BlogComment, "title">
```
----

```ts
type Resolve<T> = T extends Function ? T : {[K in keyof T]: T[K]};
```
----

```ts
type PartiallyPartial<T, K extends keyof T> =
  Resolve<Partial<Pick<T, K>> & Omit<T, K>>;

type PartComment = PartiallyPartial<BlogComment, 'title'>;
//   ^? type PartComment = {
//          title?: string | undefined;
//          commentId: number;
//          content: string;
//      }
```
----

```ts
type ObjIdentity<T> = {[K in keyof T]: T[K]};
```
----

```ts
type S = ObjIdentity<string>;
//   ^? type S = string
type N = ObjIdentity<number>;
//   ^? type N = number
type U = ObjIdentity<'A' | 'B' | 'C'>;
//   ^? type U = "A" | "B" | "C"
```
----

```ts
type F = ObjIdentity<(a: number) => boolean>;
//   ^? type F = {}
```
----

```ts
type D = Resolve<Date>;
//   ^? type D = {
//        toLocaleString: {
//            (locales?: Intl.LocalesArgument,
//             options?: Intl.DateTimeFormatOptions | undefined): string;
//            (): string;
//            (locales?: string | string[] | undefined,
//             options?: Intl.DateTimeFormatOptions | undefined): string;
//        };
//        ... 42 more ...;
//        [Symbol.toPrimitive]: {
//            ...;
//        };
//      }
```
----

```ts
interface Color { r: number; g: number; b: number; a: number };
type Chan = keyof Color;
//   ^? type Chan = keyof Color
type ChanInline = Resolve<keyof Color>;
//   ^? type ChanInline = "r" | "g" | "b" | "a"
```
----

```ts
type FullComment = PartiallyPartial<BlogComment, never>;
//   ^? type FullComment = {
//             title: string;
//             commentId: number;
//             content: string;
//           }
```
----

```ts
type PartiallyPartial<T extends object, K extends keyof T> =
  [K] extends [never]
  ? T  // special case
  : T extends unknown  // extra conditional to preserve distribution over unions
  ? Resolve<Partial<Pick<T, K>> & Omit<T, K>>
  : never;

type FullComment = PartiallyPartial<BlogComment, never>;
//   ^? type FullComment = BlogComment
```
---
effective-typescript-main/samples/ch-generics/control-distribution.md
---
# Item 53: Know How to Control the Distribution of Unions over Conditional Types

## Things to Remember

- Think about whether you want unions to distribute over your conditional types.
- Know how to enable or disable distribution by adding conditions or by wrapping conditions in one-tuples.
- Be aware of the surprising behavior of `boolean` and `never` types when they distribute over unions.

## Code Samples

```ts
declare function double<T extends number | string>(
  x: T
): T extends string ? string : number;

const num = double(12);
//    ^? const num: number
const str = double('x');
//    ^? const str: string

declare let numOrStr: number | string;
const either = double(numOrStr);
//    ^? const either: number | string
```
----

```ts
type Comparable<T> =
    T extends Date ? Date | number:
    T extends number ? number :
    T extends string ? string :
    never;

declare function isLessThan<T>(a: T, b: Comparable<T>): boolean;
```
----

```ts
isLessThan(new Date(), new Date());  // ok
isLessThan(new Date(), Date.now());  // ok, Date/number comparison allowed
isLessThan(12, 23);  // ok
isLessThan('A', 'B');  // ok
isLessThan(12, 'B');
//             ~~~ Argument of type 'string' is not assignable to parameter
//                 of type 'number'.
```
----

```ts
let dateOrStr = Math.random() < 0.5 ? new Date() : 'A';
//  ^? let dateOrStr: Date | string
isLessThan(dateOrStr, 'B')  // ok, but should be an error
```
----

```ts
type Comparable<T> =
    [T] extends [Date] ? Date | number:
    [T] extends [number] ? number :
    [T] extends [string] ? string :
    never;
```
----

```ts
isLessThan(new Date(), new Date());  // ok
isLessThan(new Date(), Date.now());  // ok, Date/number comparison allowed
isLessThan(12, 23);  // ok
isLessThan('A', 'B');  // ok
isLessThan(12, 'B');
//             ~~~ Argument of type 'string' is not assignable to parameter
//                 of type 'number'.
isLessThan(dateOrStr, 'B');
//                    ~~~ Argument of type 'string' is not assignable to
//                        parameter of type 'never'.
```
----

```ts
type NTuple<T, N extends number> = NTupleHelp<T, N, []>;

type NTupleHelp<T, N extends number, Acc extends T[]> =
  Acc['length'] extends N
  ? Acc
  : NTupleHelp<T, N, [T, ...Acc]>;
```
----

```ts
type PairOfStrings = NTuple<string, 2>;
//   ^? type PairOfStrings = [string, string]
type TripleOfNumbers = NTuple<number, 3>;
//   ^? type TripleOfNumbers = [number, number, number]
```
----

```ts
type PairOrTriple = NTuple<bigint, 2 | 3>;
//   ^? type PairOrTriple = [bigint, bigint]
```
----

```ts
type NTuple<T, N extends number> =
    N extends number
    ? NTupleHelp<T, N, []>
    : never;
```
----

```ts
type PairOrTriple = NTuple<bigint, 2 | 3>;
//   ^? type PairOrTriple = [bigint, bigint] | [bigint, bigint, bigint]
```
----

```ts
type CelebrateIfTrue<V> = V extends true ? 'Huzzah!' : never;

type Party = CelebrateIfTrue<true>;
//   ^? type Party = "Huzzah!"
type NoParty = CelebrateIfTrue<false>;
//   ^? type NoParty = never
type SurpriseParty = CelebrateIfTrue<boolean>;
//   ^? type SurpriseParty = "Huzzah!"
```
----

```ts
type CelebrateIfTrue<V> = [V] extends [true] ? 'Huzzah!' : never;

type SurpriseParty = CelebrateIfTrue<boolean>;
//   ^? type SurpriseParty = never
```
----

```ts
type AllowIn<T> = T extends {password: "open-sesame"} ? "Yes" : "No";
```
----

```ts
type N = AllowIn<never>;
//   ^? type N = never
```
---
effective-typescript-main/samples/ch-generics/functions-on-types.md
---
# Item 50: Think of Generics as Functions Between Types

## Things to Remember

- Think of generic types as functions between types.
- Use `extends` to constrain the domain of type parameters, just as you'd use a type annotation to constrain a function parameter.
- Choose type parameter names that increase the legibility of your code, and write TSDoc for them.
- Think of generic functions and classes as conceptually defining generic types that are conducive to type inference.

## Code Samples

```ts
type MyPartial<T> = {[K in keyof T]?: T[K]};
```
----

```ts
interface Person {
  name: string;
  age: number;
}

type MyPartPerson = MyPartial<Person>;
//   ^? type MyPartPerson = { name?: string; age?: number; }

type PartPerson = Partial<Person>;
//   ^? type PartPerson = { name?: string; age?: number; }
```
----

```ts
type MyPick<T, K> = {
  [P in K]: T[P]
  //    ~        Type 'K' is not assignable to type 'string | number | symbol'.
  //        ~~~~ Type 'P' cannot be used to index type 'T'.
};
```
----

```ts
// @ts-expect-error (don't do this!)
type MyPick<T, K> = { [P in K]: T[P] };
type AgeOnly = MyPick<Person, 'age'>;
//   ^? type AgeOnly = { age: number; }
```
----

```ts
type FirstNameOnly = MyPick<Person, 'firstName'>;
//   ^? type FirstNameOnly = { firstName: unknown; }
type Flip = MyPick<'age', Person>;
//   ^? type Flip = {}
```
----

```ts
type MyPick<T, K> = { [P in K & PropertyKey]: T[P & keyof T] };

type AgeOnly = MyPick<Person, 'age'>;
//   ^? type AgeOnly = { age: number; }
type FirstNameOnly = MyPick<Person, 'firstName'>;
//   ^? type FirstNameOnly = { firstName: never; }
```
----

```ts
type MyPick<T extends object, K extends keyof T> = {[P in K]: T[P]};

type AgeOnly = MyPick<Person, 'age'>;
//   ^? type AgeOnly = { age: number; }
type FirstNameOnly = MyPick<Person, 'firstName'>;
//                                  ~~~~~~~~~~~
//            Type '"firstName"' does not satisfy the constraint 'keyof Person'.
type Flip = MyPick<'age', Person>;
//                 ~~~~~ Type 'string' does not satisfy the constraint 'object'.
```
----

```ts
/**
 * Construct a new object type using a subset of the properties of another one
 * (same as the built-in `Pick` type).
 * @template T The original object type
 * @template K The keys to pick, typically a union of string literal types.
 */
type MyPick<T extends object, K extends keyof T> = {
  [P in K]: T[P]
};
```
----

```ts
function pick<T extends object, K extends keyof T>(
  obj: T, ...keys: K[]
): Pick<T, K> {
  const picked: Partial<Pick<T, K>> = {};
  for (const k of keys) {
    picked[k] = obj[k];
  }
  return picked as Pick<T, K>;
}

const p: Person = { name: 'Matilda', age: 5.5 };
const age = pick(p, 'age');
//    ^? const age: Pick<Person, "age">
console.log(age);  // logs { age: 5.5 }
```
----

```ts
type P = typeof pick;
//   ^? type P = <T extends object, K extends keyof T>(
//         obj: T, ...keys: K[]
//      ) => Pick<T, K>
```
----

```ts
const age = pick<Person, 'age'>(p, 'age');
//    ^? const age: Pick<Person, "age">
```
----

```ts
class Box<T> {
  value: T;
  constructor(value: T) {
    this.value = value;
  }
}

const dateBox = new Box(new Date());
//    ^? const dateBox: Box<Date>
```
----

```ts
type MapValues<T extends object, F> = {
  [K in keyof T]: F<T[K]>;
  //              ~~~~~~~ Type 'F' is not generic.
};
```
---
effective-typescript-main/samples/ch-generics/test-your-types.md
---
# Item 55: Write Tests for Your Types

## Things to Remember

- When testing types, be aware of the difference between equality and assignability, particularly for function types.
- For functions that use callbacks, test the inferred types of the callback parameters. Don't forget to test the type of `this` if it's part of your API.
- Avoid writing your own type testing code. Use one of the standard tools instead.
- For code on DefinitelyTyped, use `dtslint`. For your own code, use `vitest`, `expect-type`, or the Type Challenges approach. If you want to test type display, use `eslint-plugin-expect-type`.

## Code Samples

```ts
declare function map<U, V>(array: U[], fn: (u: U) => V): V[];
```
----

```ts
map(['2017', '2018', '2019'], v => Number(v));
```
----

```ts
test('square a number', () => {
  square(1);
  square(2);
});
```
----

```ts
const lengths: number[] = map(['john', 'paul'], name => name.length);
```
----

```ts
function assertType<T>(x: T) {}

assertType<number[]>(map(['john', 'paul'], name => name.length));
```
----

```ts
const n = 12;
assertType<number>(n);  // OK
```
----

```ts
const beatles = ['john', 'paul', 'george', 'ringo'];
assertType<{name: string}[]>(
  map(beatles, name => ({
    name,
    inYellowSubmarine: name === 'ringo'
  }))
);  // OK
```
----

```ts
const add = (a: number, b: number) => a + b;
assertType<(a: number, b: number) => number>(add);  // OK

const double = (x: number) => 2 * x;
assertType<(a: number, b: number) => number>(double);  // OK!?
```
----

```ts
const g: (x: string) => any = () => 12;  // OK
```
----

```ts
const double = (x: number) => 2 * x;
declare let p: Parameters<typeof double>;
assertType<[number, number]>(p);
//                           ~ Argument of type '[number]' is not
//                             assignable to parameter of type [number, number]
declare let r: ReturnType<typeof double>;
assertType<number>(r);  // OK
```
----

```ts
const beatles = ['john', 'paul', 'george', 'ringo'];
assertType<number[]>(map(
  beatles,
  function(name, i, array) {
    // ~~~ Argument of type '(name: any, i: any, array: any) => any' is
    //     not assignable to parameter of type '(u: string) => any'
    assertType<string>(name);
    assertType<number>(i);
    assertType<string[]>(array);
    assertType<string[]>(this);
    //                   ~~~~ 'this' implicitly has type 'any'
    return name.length;
  }
));
```
----

```ts
declare function map<U, V>(
  array: U[],
  fn: (this: U[], u: U, i: number, array: U[]) => V
): V[];
```
----

```ts
declare module 'your-amazing-module';
```
----

```ts
// @ts-expect-error only takes two parameters
map([1, 2, 3], x => x * x, 'third parameter');
```
----

```ts
declare const map: any;
map([1, 2, 3], x => x * x, 'third parameter');
//             ~ Parameter 'x' implicitly has an 'any' type.
```
----

```ts
map(
  [1, 2, 3],
  x => x * x,
  // @ts-expect-error only takes two parameters
  'third parameter'
);
```
----

```ts
import {expectTypeOf} from 'expect-type';

const beatles = ['john', 'paul', 'george', 'ringo'];
expectTypeOf(map(
  beatles,
  function(name, i, array) {
    expectTypeOf(name).toEqualTypeOf<string>();
    expectTypeOf(i).toEqualTypeOf<number>();
    expectTypeOf(array).toEqualTypeOf<string[]>();
    expectTypeOf(this).toEqualTypeOf<string[]>();
    return name.length;
  }
)).toEqualTypeOf<number[]>();
```
----

```ts
const anyVal: any = 1;
expectTypeOf(anyVal).toEqualTypeOf<number>();
//                                 ~~~~~~
//           Type 'number' does not satisfy the constraint 'never'.

const double = (x: number) => 2 * x;
expectTypeOf(double).toEqualTypeOf<(a: number, b: number) => number>();
//                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//           Type ... does not satisfy '"Expected: function, Actual: never"'

interface ABReadOnly {
  readonly a: string;
  b: number;
}
declare let ab: {a: string, b: number};
expectTypeOf(ab).toEqualTypeOf<ABReadOnly>();
//               ~~~~~~~~~~~~~
//           Arguments for the rest parameter 'MISMATCH' were not provided.
expectTypeOf(ab).toEqualTypeOf<{a: string, b: number}>();  // OK
```
----

```ts
export type Equals<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends
  (<T>() => T extends Y ? 1 : 2) ? true : false;

export type Expect<T extends true> = T;

const double = (x: number) => 2 * x;
type Test1 = Expect<Equals<typeof double, (x: number) => number>>;
type Test2 = Expect<Equals<typeof double, (x: string) => number>>;
//                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//                  Type 'false' does not satisfy the constraint 'true'.
```
----

```ts
type Test3 = Expect<Equals<1 | 2, 2 | 1>>;  // good!
type Test4 = Expect<Equals<[a: 1, b: 2], [1, 2]>>;  // maybe not so good
type Test5 = Expect<Equals<{x: 1} & {y: 2}, {x: 1, y: 2}>>;  // surprising
//                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//                  Type 'false' does not satisfy the constraint 'true'.
```
----

```ts
const beatles = ['john', 'paul', 'george', 'ringo'];
map(beatles, function(
  name,  // $ExpectType string
  i,     // $ExpectType number
  array  // $ExpectType string[]
) {
  this   // $ExpectType string[]
  return name.length;
});  // $ExpectType number[]
```
----

```ts
const spiceGirls = ['scary', 'sporty', 'baby', 'ginger', 'posh'];
//    ^? const spiceGirls: string[]
```
----

```ts
type Game = 'wordle' | 'crossword' | (string & {});
const spellingBee: Game = 'spelling bee';
let g: Game = '';
```
---
effective-typescript-main/samples/ch-generics/golden-rule.md
---
# Item 51: Avoid Unnecessary Type Parameters

## Things to Remember

- Avoid adding type parameters to functions and classes that don't need them.
- Since type parameters relate types, every type parameter must appear two or more times to establish a relationship.
- Remember that a type parameter may appear in an inferred type.
- Avoid "return-only generics."
- Unneeded type parameters can often be replaced with the `unknown` type.

## Code Samples

```ts
function identity<T>(arg: T): T {
  return arg;
}
```
----

```ts
const date = identity(new Date());
//    ^? const date: Date
const nums = [1, 2, 3];
//    ^? const nums: number[]
const numsCopy = nums.map(identity);
//    ^? const numsCopy: number[]
```
----

```ts
function identity<T>(arg: T): T {
  //           (decl.)    1   2
  return arg;
}
```
----

```ts
function third<A, B, C>(a: A, b: B, c: C): C {
  return c;
}
```
----

```ts
function third<C>(a: unknown, b: unknown, c: C): C {
  return c;
}
```
----

```ts
declare function parseYAML<T>(input: string): T;
```
----

```ts
interface Weight {
  pounds: number;
  ounces: number;
}

const w: Weight = parseYAML('');
```
----

```ts
declare function parseYAML<T=null>(input: string): T;
const w: Weight = parseYAML('');  // still allowed
```
----

```ts
declare function parseYAML(input: string): unknown;
```
----

```ts
const w = parseYAML('') as Weight;
```
----

```ts
function printProperty<T, K extends keyof T>(obj: T, key: K) {
  console.log(obj[key]);
}
```
----

```ts
function printProperty<T>(obj: T, key: keyof T) {
  console.log(obj[key]);
}
```
----

```ts
function getProperty<T, K extends keyof T>(obj: T, key: K) {
  return obj[key];
}
```
----

```ts
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}
```
----

```ts
class ClassyArray<T> {
  arr: T[];
  constructor(arr: T[]) { this.arr = arr; }

  get(): T[] { return this.arr; }
  add(item: T) { this.arr.push(item); }
  remove(item: T) {
    this.arr = this.arr.filter(el => el !== item)
  }
}
```
----

```ts
class Joiner<T extends string | number> {
  join(els: T[]) {
    return els.map(el => String(el)).join(',');
  }
}
```
----

```ts
class Joiner {
  join<T extends string | number>(els: T[]) {
    return els.map(el => String(el)).join(',');
  }
}
```
----

```ts
class Joiner {
  join(els: (string | number)[]) {
    return els.map(el => String(el)).join(',');
  }
}
```
----

```ts
function join(els: (string|number)[]) {
  return els.map(el => String(el)).join(',');
}
```
----

```ts
interface Lengthy {
  length: number;
}
function getLength<T extends Lengthy>(x: T) {
  return x.length;
}
```
----

```ts
function getLength(x: Lengthy) {
  return x.length;
}
```
----

```ts
function getLength(x: {length: number}) {
  return x.length;
}
```
----

```ts
function getLength(x: ArrayLike<unknown>) {
  return x.length;
}
```
----

```ts
declare function processUnrelatedTypes<A, B>(a: A, b: B): void;
```
----

```ts
declare function processUnrelatedTypes(a: unknown, b: unknown): void;
```
----

```ts
function processUnrelatedTypes<A, B>(a: A, b: B) {
    a = b;
//  ~ Type 'B' is not assignable to type 'A'.
    b = a;
//  ~ Type 'A' is not assignable to type 'B'.
}
```
----

```ts
function processUnrelatedTypes(a: unknown, b: unknown) {
  a = b;  // ok
  b = a;  // ok
}
```
---
effective-typescript-main/samples/ch-generics/codegen-alt.md
---
# Item 58: Consider Codegen as an Alternative to Complex Types

## Things to Remember

- While type-level TypeScript is an impressively powerful tool, it's not always the best tool for the job.
- For complex type manipulations, consider generating code and types as an alternative to writing type-level code. Your code generation tool can be written in ordinary TypeScript or any other language.
- Run codegen and `git diff` on your continuous integration system to make sure generated code stays in sync.## Code Samples

```ts
async function getBooks(db: Database) {
  const result = await db.query(
    `SELECT title, author, year, publisher FROM books`
  );
  return result.rows;
}
```
----

```ts
async function getLatestBookByAuthor(db: Database, publisher: string) {
  const result = await db.query(
    `SELECT author, MAX(year) FROM books GROUP BY author WHERE publisher=$1`,
    [publisher]
  );
  return result.rows;
}
```
----

```ts
// books-queries.ts
import { sql } from '@pgtyped/runtime';
const selectLatest = sql`
    SELECT author, MAX(year)
    FROM books
    GROUP BY author
    WHERE publisher=$publisher
`;

async function getLatestBookByAuthor(db: Database, publisher: string) {
  const result = await selectLatest.run({publisher}, db);
  //    ^? const result: any[]
  return result;
}
```
----

```ts
// books-queries.types.ts
/** Types generated for queries found in "books-queries.ts" */

/** 'selectLatest' parameters type */
export interface selectLatestParams {
  publisher: string;
}

/** 'selectLatest' return type */
export interface selectLatestResult {
  author: string;
  year: number;
}

/** 'selectLatest' query type */
export interface selectLatestQuery {
  params: selectLatestParams;
  result: selectLatestResult;
}
```
----

```ts
// books-queries.ts
import { sql } from '@pgtyped/runtime';
import { selectLatestQuery } from './books-queries.types';
export const selectLatestBookByAuthor = sql<selectLatestQuery>`
    SELECT author, MAX(year)
    FROM books
    GROUP BY author
    WHERE publisher=$publisher
`;

async function getLatestBookByAuthor(db: Database, publisher: string) {
  const result = await selectLatestBookByAuthor.run({publisher}, db);
  //    ^? const result: selectLatestResult[]
  return result;
}
```
---
effective-typescript-main/samples/ch-generics/tail-recursion.md
---
# Item 57: Prefer Tail-Recursive Generic Types

## Things to Remember

- Aim to make your recursive generic types tail recursive. They're more efficient and have greater depth limits.
- Recursive type aliases can often be made tail recursive by rewriting them to use an accumulator.

## Code Samples

```ts
function sum(nums: readonly number[]): number {
  if (nums.length === 0) {
    return 0;
  }
  return nums[0] + sum(nums.slice(1));
}

console.log(sum([0, 1, 2, 3, 4]));
```
----

```ts
const arr = Array(7875).fill(1);
console.log(sum(arr));
```
----

```ts
function sum(nums: readonly number[], acc=0): number {
  if (nums.length === 0) {
    return acc;
  }
  return sum(nums.slice(1), nums[0] + acc);
}
```
----

```ts
type GetChars<S extends string> =
    S extends `${infer FirstChar}${infer RestOfString}`
    ? FirstChar | GetChars<RestOfString>
    : never;

type ABC = GetChars<"abc">;
//   ^? type ABC = "a" | "b" | "c"
```
----

```ts
type Long = GetChars<"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWX">;
//          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//          Type instantiation is excessively deep and possibly infinite.
```
----

```ts
type ToSnake<T extends string> =
    string extends T
    ? string  // We want ToSnake<string> = string
    : T extends `${infer First}${infer Rest}`
    ? (First extends Uppercase<First>  // Is First a capital letter?
      ? `_${Lowercase<First>}${ToSnake<Rest>}`  // e.g. "B" -> "_b"
      : `${First}${ToSnake<Rest>}`)
    : T;

type S = ToSnake<'fooBarBaz'>;
//   ^? type S = "foo_bar_baz"

type Two = ToSnake<'className' | 'tagName'>;
//   ^? type Two = "class_name" | "tag_name"
```
----

```ts
type Long = ToSnake<'reallyDescriptiveNamePropThatsALittleTooLoquacious'>;
//          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//          Type instantiation is excessively deep and possibly infinite.
```
----

```ts
type ToSnake<T extends string, Acc extends string = ""> =
  string extends T
  ? string  // We want ToSnake<string> = string
  : T extends `${infer First}${infer Rest}`
  ? ToSnake<
      Rest,
      First extends Uppercase<First>
      ? `${Acc}_${Lowercase<First>}`
      : `${Acc}${First}`
    >
  : Acc;

type S = ToSnake<'fooBarBaz'>;
//   ^? type S = "foo_bar_baz"

type Two = ToSnake<'className' | 'tagName'>;
//   ^? type Two = "class_name" | "tag_name"

type Long = ToSnake<'reallyDescriptiveNamePropThatsALittleTooLoquacious'>;
//   ^? type Long = "really_descriptive_name_prop_thats_a_little_too_loquacious"
```
---
effective-typescript-main/samples/ch-generics/conditional-overload.md
---
# Item 52: Prefer Conditional Types to Overload Signatures

## Things to Remember

- Prefer conditional types to overloaded type signatures. By distributing over unions, conditional types allow your declarations to support union types without additional overloads.
- If the union case is implausible, consider whether your function would be clearer as two or more functions with different names.
- Consider using the single overload strategy for implementing functions declared with conditional types.

## Code Samples

```ts
declare function double(x: string | number): string | number;
```
----

```ts
const num = double(12);
//    ^? const num: string | number
const str = double('x');
//    ^? const str: string | number
```
----

```ts
declare function double<T extends string | number>(x: T): T;

const num = double(12);
//    ^? const num: 12
const str = double('x');
//    ^? const str: "x"
```
----

```ts
declare function double(x: number): number;
declare function double(x: string): string;

const num = double(12);
//    ^? const num: number
const str = double('x');
//    ^? const str: string
```
----

```ts
function f(x: string | number) {
  return double(x);
  //            ~ Argument of type 'string | number' is not assignable
  //              to parameter of type 'string'
}
```
----

```ts
declare function double<T extends string | number>(
  x: T
): T extends string ? string : number;
```
----

```ts
const num = double(12);
//    ^? const num: number
const str = double('x');
//    ^? const str: string

function f(x: string | number) {
  //     ^? function f(x: string | number): string | number
  return double(x);  // ok
}
```
----

```ts
function double<T extends string | number>(
  x: T
): T extends string ? string : number;
function double(x: string | number): string | number {
  return typeof x === 'string' ? x + x : x + x;
}
```
---
effective-typescript-main/samples/ch-generics/template-dsl.md
---
# Item 54: Use Template Literal Types to Model DSLs and Relationships Between Strings

## Things to Remember

- Use template literal types to model structured subsets of `string` types and domain-specific languages (DSLs).
- Combine template literal types with mapped and conditional types to capture nuanced relationships between types.
- Take care to avoid crossing the line into inaccurate types. Strive for uses of template literal types that improve developer experience without requiring knowledge of fancy language features.

////## Code Samples

```ts
type MedalColor = 'gold' | 'silver' | 'bronze';
```
----

```ts
type PseudoString = `pseudo${string}`;
const science: PseudoString = 'pseudoscience';  // ok
const alias: PseudoString = 'pseudonym';  // ok
const physics: PseudoString = 'physics';
//    ~~~~~~~ Type '"physics"' is not assignable to type '`pseudo${string}`'.
```
----

```ts
interface Checkbox {
  id: string;
  checked: boolean;
  [key: `data-${string}`]: unknown;
}

const check1: Checkbox = {
  id: 'subscribe',
  checked: true,
  value: 'yes',
// ~~~~ Object literal may only specify known properties,
//        and 'value' does not exist in type 'Checkbox'.
  'data-listIds': 'all-the-lists',  // ok
};
const check2: Checkbox = {
  id: 'subscribe',
  checked: true,
  listIds: 'all-the-lists',
// ~~~~~~ Object literal may only specify known properties,
//          and 'listIds' does not exist in type 'Checkbox'
};
```
----

```ts
interface Checkbox {
  id: string;
  checked: boolean;
  [key: string]: unknown;
}

const check1: Checkbox = {
  id: 'subscribe',
  checked: true,
  value: 'yes',  // permitted
  'data-listIds': 'all-the-lists',
};
const check2: Checkbox = {
  id: 'subscribe',
  checked: true,
  listIds: 'all-the-lists'  // also permitted, matches index type
};
```
----

```ts
const img = document.querySelector('img');
//    ^? const img: HTMLImageElement | null
```
----

```ts
const img = document.querySelector('img#spectacular-sunset');
//    ^? const img: Element | null
img?.src
//   ~~~ Property 'src' does not exist on type 'Element'.
```
----

```ts
interface HTMLElementTagNameMap {
  "a": HTMLAnchorElement;
  "abbr": HTMLElement;
  "address": HTMLElement;
  "area": HTMLAreaElement;
  // ... many more ...
  "video": HTMLVideoElement;
  "wbr": HTMLElement;
}
```
----

```ts
interface ParentNode extends Node {
  // ...
  querySelector<E extends Element = Element>(selectors: string): E | null;
  // ...
}
```
----

```ts
type HTMLTag = keyof HTMLElementTagNameMap;
declare global {
  interface ParentNode {
    querySelector<
      TagName extends HTMLTag
    >(
      selector: `${TagName}#${string}`
    ): HTMLElementTagNameMap[TagName] | null;
  }
}
```
----

```ts
const img = document.querySelector('img#spectacular-sunset');
//    ^? const img: HTMLImageElement | null
img?.src  // ok
```
----

```ts
const img = document.querySelector('div#container img');
//    ^? const img: HTMLDivElement | null
```
----

```ts
type CSSSpecialChars = ' ' | '>' | '+' | '~' | '||' | ',';
type HTMLTag = keyof HTMLElementTagNameMap;

declare global {
  interface ParentNode {
    // escape hatch
    querySelector(
      selector: `${HTMLTag}#${string}${CSSSpecialChars}${string}`
    ): Element | null;

    // same as before
    querySelector<
      TagName extends HTMLTag
    >(
      selector: `${TagName}#${string}`
    ): HTMLElementTagNameMap[TagName] | null;
  }
}
```
----

```ts
const img = document.querySelector('img#spectacular-sunset');
//    ^? const img: HTMLImageElement | null
const img2 = document.querySelector('div#container img');
//    ^? const img2: Element | null
```
----

```ts
// e.g. foo_bar -> fooBar
function camelCase(term: string) {
  return term.replace(/_([a-z])/g, m => m[1].toUpperCase());
}

// (return type to be filled in shortly)
function objectToCamel<T extends object>(obj: T) {
  const out: any = {};
  for (const [k, v] of Object.entries(obj)) {
    out[camelCase(k)] = v;
  }
  return out;
}

const snake = {foo_bar: 12};
//    ^? const snake: { foo_bar: number; }
const camel = objectToCamel(snake);
// camel's value at runtime is {fooBar: 12};
// we'd like the type to be {fooBar: number}
const val = camel.fooBar;  // we'd like this to have a number type
const val2 = camel.foo_bar;  // we'd like this to be an error
```
----

```ts
type ToCamelOnce<S extends string> =
    S extends `${infer Head}_${infer Tail}`
    ? `${Head}${Capitalize<Tail>}`
    : S;

type T = ToCamelOnce<'foo_bar'>;  // type is "fooBar"
```
----

```ts
type ToCamel<S extends string> =
    S extends `${infer Head}_${infer Tail}`
    ? `${Head}${Capitalize<ToCamel<Tail>>}`
    : S;
type T0 = ToCamel<'foo'>;  // type is "foo"
type T1 = ToCamel<'foo_bar'>;  // type is "fooBar"
type T2 = ToCamel<'foo_bar_baz'>;  // type is "fooBarBaz"
```
----

```ts
type ObjectToCamel<T extends object> = {
  [K in keyof T as ToCamel<K & string>]: T[K]
};

function objectToCamel<T extends object>(obj: T): ObjectToCamel<T> {
  // ... as before ...
}
```
----

```ts
const snake = {foo_bar: 12};
//    ^? const snake: { foo_bar: number; }
const camel = objectToCamel(snake);
//    ^? const camel: ObjectToCamel<{ foo_bar: number; }>
//                    (equivalent to { fooBar: number; })
const val = camel.fooBar;
//    ^? const val: number
const val2 = camel.foo_bar;
//                 ~~~~~~~ Property 'foo_bar' does not exist on type
//                         '{ fooBar: number; }'. Did you mean 'fooBar'?
```
---
effective-typescript-main/samples/ch-types/type-vs-interface.md
---
# Item 13: Know the Differences Between type and interface

## Things to Remember

- Understand the differences and similarities between `type` and `interface`.
- Know how to write the same types using either syntax.
- Be aware of declaration merging for `interface` and type inlining for `type`.
- For projects without an established style, prefer `interface` to `type` for object types.


## Code Samples

```ts
type TState = {
  name: string;
  capital: string;
};
```
----

```ts
interface IState {
  name: string;
  capital: string;
}
```
----

```ts
const wyoming: TState = {
  name: 'Wyoming',
  capital: 'Cheyenne',
  population: 578_000
  // ~~~~~~~ Object literal may only specify known properties,
  //         and 'population' does not exist in type 'TState'
};
```
----

```ts
type TDict = { [key: string]: string };
interface IDict {
  [key: string]: string;
}
```
----

```ts
type TFn = (x: number) => string;
interface IFn {
  (x: number): string;
}
type TFnAlt = {
  (x: number): string;
};

const toStrT: TFn = x => '' + x;  // OK
const toStrI: IFn = x => '' + x;  // OK
const toStrTAlt: TFnAlt = x => '' + x;  // OK
```
----

```ts
type TBox<T> = {
  value: T;
};
interface IBox<T> {
  value: T;
}
```
----

```ts
interface IStateWithPop extends TState {
  population: number;
}
type TStateWithPop = IState & { population: number; };
```
----

```ts
class StateT implements TState {
  name: string = '';
  capital: string = '';
}
class StateI implements IState {
  name: string = '';
  capital: string = '';
}
```
----

```ts
type AorB = 'a' | 'b';
```
----

```ts
type Input = { /* ... */ };
type Output = { /* ... */ };
interface VariableMap {
  [name: string]: Input | Output;
}
```
----

```ts
type NamedVariable = (Input | Output) & { name: string };
```
----

```ts
interface Person {
  name: string;
  age: string;
}

type TPerson = Person & { age: number; };  // no error, unusable type

interface IPerson extends Person {
  //      ~~~~~~~ Interface 'IPerson' incorrectly extends interface 'Person'.
  //                Types of property 'age' are incompatible.
  //                  Type 'number' is not assignable to type 'string'.
  age: number;
}
```
----

```ts
type Pair = [a: number, b: number];
type StringList = string[];
type NamedNums = [string, ...number[]];
```
----

```ts
interface IState {
  name: string;
  capital: string;
}
interface IState {
  population: number;
}
const wyoming: IState = {
  name: 'Wyoming',
  capital: 'Cheyenne',
  population: 578_000
};  // OK
```
----

```ts
// lib.es5.d.ts
interface Array<T> {
  /** Gets or sets the length of the array. */
  length: number;
  // ...
  [n: number]: T;
}
```
----

```ts
// lib.es2015.core.d.ts
interface Array<T> {
  /** Returns the index of the first element in the array where predicate... */
  findIndex(
    predicate: (value: T, index: number, obj: T[]) => unknown,
    thisArg?: any
  ): number;

  // ... also find, fill, copyWithin
}
```
----

```ts
export function getHummer() {
  type Hummingbird = { name: string; weightGrams: number; };
  const ruby: Hummingbird = { name: 'Ruby-throated', weightGrams: 3.4 };
  return ruby;
};

const rubyThroat = getHummer();
//    ^? const rubyThroat: Hummingbird
```
----

```ts
// get-hummer.d.ts
export declare function getHummer(): {
  name: string;
  weightGrams: number;
};
```
----

```ts
export function getHummer() {
  //            ~~~~~~~~~
  // Return type of exported function has or is using private name 'Hummingbird'.
  interface Hummingbird { name: string; weightGrams: number; };
  const bee: Hummingbird = { name: 'Bee Hummingbird', weightGrams: 2.3 };
  return bee;
};
```
---
effective-typescript-main/samples/ch-types/excess-property-checking.md
---
# Item 11: Distinguish Excess Property Checking from Type Checking

## Things to Remember

- When you assign an object literal to a variable with a known type or pass it as an argument to a function, it undergoes excess property checking.
- Excess property checking is an effective way to find errors, but it is distinct from the usual structural assignability checks done by the TypeScript type checker. Conflating these processes will make it harder for you to build a mental model of assignability. TypeScript types are not "closed" (pass:[<a href="#structural">Item 4</a>]).
- Be aware of the limits of excess property checking: introducing an intermediate variable will remove these checks.
- A "weak type" is an object type with only optional properties. For these types, assignability checks require at least one matching property.


## Code Samples

```ts
interface Room {
  numDoors: number;
  ceilingHeightFt: number;
}
const r: Room = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: 'present',
// ~~~~~~~ Object literal may only specify known properties,
//         and 'elephant' does not exist in type 'Room'
};
```
----

```ts
const obj = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: 'present',
};
const r: Room = obj;  // OK
```
----

```ts
interface Options {
  title: string;
  darkMode?: boolean;
}
function createWindow(options: Options) {
  if (options.darkMode) {
    setDarkMode();
  }
  // ...
}
createWindow({
  title: 'Spider Solitaire',
  darkmode: true
// ~~~~~~~ Object literal may only specify known properties,
//         but 'darkmode' does not exist in type 'Options'.
//         Did you mean to write 'darkMode'?
});
```
----

```ts
const o1: Options = document;  // OK
const o2: Options = new HTMLAnchorElement();  // OK
```
----

```ts
const o: Options = { darkmode: true, title: 'Ski Free' };
                  // ~~~~~~~~ 'darkmode' does not exist in type 'Options'...
```
----

```ts
const intermediate = { darkmode: true, title: 'Ski Free' };
const o: Options = intermediate;  // OK
```
----

```ts
const o = { darkmode: true, title: 'MS Hearts' } as Options;  // OK
```
----

```ts
interface Options {
  darkMode?: boolean;
  [otherOptions: string]: unknown;
}
const o: Options = { darkmode: true };  // OK
```
----

```ts
interface LineChartOptions {
  logscale?: boolean;
  invertedYAxis?: boolean;
  areaChart?: boolean;
}
function setOptions(options: LineChartOptions) { /* ... */ }

const opts = { logScale: true };
setOptions(opts);
//         ~~~~ Type '{ logScale: boolean; }' has no properties in common
//              with type 'LineChartOptions'
```
---
effective-typescript-main/samples/ch-types/type-value-space.md
---
# Item 8: Know How to Tell Whether a Symbol Is in the Type Space or Value Space

## Things to Remember

- Know how to tell whether you're in type space or value space while reading a TypeScript expression. Use the TypeScript playground to build an intuition for this.
- Every value has a static type, but this is only accessible in type space. Type space constructs such as `type` and `interface` are erased and are not accessible in value space.
- Some constructs, such as `class` or `enum`, introduce both a type and a value.
- `typeof`, `this`, and many other operators and keywords have different meanings in type space and value space.


## Code Samples

```ts
interface Cylinder {
  radius: number;
  height: number;
}

const Cylinder = (radius: number, height: number) => ({radius, height});
```
----

```ts
function calculateVolume(shape: unknown) {
  if (shape instanceof Cylinder) {
    shape.radius
    //    ~~~~~~ Property 'radius' does not exist on type '{}'
  }
}
```
----

```ts
type T1 = 'string literal';
const v1 = 'string literal';
type T2 = 123;
const v2 = 123;
```
----

```ts
interface Person {
  first: string;
  last: string;
}
const jane: Person = { first: 'Jane', last: 'Jacobs' };
//    ――――           ――――――――――――――――――――――――――――――――― Values
//          ―――――― Type
```
----

```ts
function email(to: Person, subject: string, body: string): Response {
  //     ――――― ――          ―――――――          ――――                    Values
  //               ――――――           ――――――        ――――――   ―――――――― Types
  // ...
}
```
----

```ts
class Cylinder {
  radius: number;
  height: number;
  constructor(radius: number, height: number) {
    this.radius = radius;
    this.height = height;
  }
}

function calculateVolume(shape: unknown) {
  if (shape instanceof Cylinder) {
    shape
    // ^? (parameter) shape: Cylinder
    shape.radius
    //    ^? (property) Cylinder.radius: number
  }
}
```
----

```ts
type T1 = typeof jane;
//   ^? type T1 = Person
type T2 = typeof email;
//   ^? type T2 = (to: Person, subject: string, body: string) => Response

const v1 = typeof jane;  // Value is "object"
const v2 = typeof email;  // Value is "function"
```
----

```ts
const first: Person['first'] = jane['first'];  // Or jane.first
//    ―――――                    ――――――――――――― Values
//           ―――――― ―――――――                  Types
```
----

```ts
type PersonEl = Person['first' | 'last'];
//   ^? type PersonEl = string
type Tuple = [string, number, Date];
type TupleEl = Tuple[number];
//   ^? type TupleEl = string | number | Date
```
----

```ts
function email(options: {to: Person, subject: string, body: string}) {
  // ...
}
```
----

```ts
function email({
  to: Person,
  //  ~~~~~~ Binding element 'Person' implicitly has an 'any' type
  subject: string,
  //       ~~~~~~ Binding element 'string' implicitly has an 'any' type
  body: string
  //    ~~~~~~ Binding element 'string' implicitly has an 'any' type
}) { /* ... */ }
```
----

```ts
function email(
  {to, subject, body}: {to: Person, subject: string, body: string}
) {
  // ...
}
```
---
effective-typescript-main/samples/ch-types/number-index.md
---
# Item 17: Avoid Numeric Index Signatures

## Things to Remember

- Understand that arrays are objects, so their keys are strings, not numbers. `number` as an index signature is a purely TypeScript construct designed to help catch bugs.
- Prefer `Array`, tuple, `ArrayLike`, or `Iterable` types to using `number` in an index signature yourself.
## Code Samples

```ts
interface Array<T> {
  // ...
  [n: number]: T;
}
```
----

```ts
const xs = [1, 2, 3];
const x0 = xs[0];  // OK
const x1 = xs['1'];  // stringified numeric constants are also OK

const inputEl = document.getElementsByTagName('input')[0];
const xN = xs[inputEl.value];
//            ~~~~~~~~~~~~~ Index expression is not of type 'number'.
```
----

```ts
const keys = Object.keys(xs);
//    ^? const keys: string[]
```
----

```ts
function checkedAccess<T>(xs: ArrayLike<T>, i: number): T {
  if (i >= 0 && i < xs.length) {
    return xs[i];
  }
  throw new Error(`Attempt to access ${i} which is past end of array.`)
}
```
----

```ts
const tupleLike: ArrayLike<string> = {
  '0': 'A',
  '1': 'B',
  length: 2,
};  // OK
```
---
effective-typescript-main/samples/ch-types/editor.md
---
# Item 6: Use Your Editor to Interrogate and Explore the Type System

## Things to Remember

- Take advantage of the TypeScript language services by using an editor that supports them.
- Use your editor to build an intuition for how the type system works and how TypeScript infers types.
- Familiarize yourself with TypeScript's refactoring tools, e.g., renaming symbols and files.
- Know how to jump into type declaration files to see how they model behavior.
## Code Samples

```ts
function getElement(elOrId: string | HTMLElement | null): HTMLElement {
  if (typeof elOrId === 'object') {
    return elOrId;
    // ~~~ Type 'HTMLElement | null' is not assignable to type 'HTMLElement'
  } else if (elOrId === null) {
    return document.body;
  }
  elOrId
  // ^? (parameter) elOrId: string
  return document.getElementById(elOrId);
  // ~~~ Type 'HTMLElement | null' is not assignable to type 'HTMLElement'
}
```
----

```ts
function getElement(elOrId: string|HTMLElement|null): HTMLElement {
  if (elOrId === null) {
    return document.body;
  } else if (typeof elOrId === 'object') {
    return elOrId;
    //     ^? (parameter) elOrId: HTMLElement
  }
  const el = document.getElementById(elOrId);
  //                                 ^? (parameter) elOrId: string
  if (!el) {
    throw new Error(`No such element ${elOrId}`);
  }
  return el;
  //     ^? const el: HTMLElement
}
```
----

```ts
let i = 0;
for (let i = 0; i < 10; i++) {
  console.log(i);
  {
    let i = 12;
    console.log(i);
  }
}
console.log(i);
```
----

```ts
let i = 0;
for (let x = 0; x < 10; x++) {
  console.log(x);
  {
    let i = 12;
    console.log(i);
  }
}
console.log(i);
```
----

```ts
declare function fetch(
  input: RequestInfo | URL, init?: RequestInit
): Promise<Response>;
```
----

```ts
interface Request extends Body {
  // ...
}
declare var Request: {
  prototype: Request;
  new(input: RequestInfo | URL, init?: RequestInit | undefined): Request;
};
```
----

```ts
interface RequestInit {
  body?: BodyInit | null;
  cache?: RequestCache;
  credentials?: RequestCredentials;
  headers?: HeadersInit;
  // ...
}
```
---
effective-typescript-main/samples/ch-types/index-for-dynamic.md
---
# Item 16: Prefer More Precise Alternatives to Index Signatures

## Things to Remember

- Understand the drawbacks of index signatures: much like `any`, they erode type safety and reduce the value of language services.
- Prefer more precise types to index signatures when possible: ++interface++s, `Map`, ++Record++s, mapped types, or index signatures with a constrained key space.
## Code Samples

```ts
const rocket = {
  name: 'Falcon 9',
  variant: 'Block 5',
  thrust: '7,607 kN',
};
```
----

```ts
type Rocket = {[property: string]: string};
const rocket: Rocket = {
  name: 'Falcon 9',
  variant: 'v1.0',
  thrust: '4,940 kN',
};  // OK
```
----

```ts
interface Rocket {
  name: string;
  variant: string;
  thrust_kN: number;
}
const falconHeavy: Rocket = {
  name: 'Falcon Heavy',
  variant: 'v1',
  thrust_kN: 15200,
};
```
----

```ts
function parseCSV(input: string): {[columnName: string]: string}[] {
  const lines = input.split('\n');
  const [headerLine, ...rows] = lines;
  const headers = headerLine.split(',');
  return rows.map(rowStr => {
    const row: {[columnName: string]: string} = {};
    rowStr.split(',').forEach((cell, i) => {
      row[headers[i]] = cell;
    });
    return row;
  });
}
```
----

```ts
interface ProductRow {
  productId: string;
  name: string;
  price: string;
}

declare let csvData: string;
const products = parseCSV(csvData) as unknown[] as ProductRow[];
```
----

```ts
function parseCSVMap(input: string): Map<string, string>[] {
  const lines = input.split('\n');
  const [headerLine, ...rows] = lines;
  const headers = headerLine.split(',');
  return rows.map(rowStr => {
    const row = new Map<string, string>();
    rowStr.split(',').forEach((cell, i) => {
      row.set(headers[i], cell);
    });
    return row;
  });
}
```
----

```ts
const rockets = parseCSVMap(csvData);
const superHeavy = rockets[2];
const thrust_kN = superHeavy.get('thrust_kN');  // 74,500
//    ^? const thrust_kN: string | undefined
```
----

```ts
function parseRocket(map: Map<string, string>): Rocket {
  const name = map.get('name');
  const variant = map.get('variant');
  const thrust_kN = Number(map.get('thrust_kN'));
  if (!name || !variant || isNaN(thrust_kN)) {
    throw new Error(`Invalid rocket: ${map}`);
  }
  return {name, variant, thrust_kN};
}
const rockets = parseCSVMap(csvData).map(parseRocket);
//    ^? const rockets: Rocket[]
```
----

```ts
interface Row1 { [column: string]: number }  // Too broad
interface Row2 { a: number; b?: number; c?: number; d?: number }  // Better
type Row3 =
    | { a: number; }
    | { a: number; b: number; }
    | { a: number; b: number; c: number;  }
    | { a: number; b: number; c: number; d: number };  // Also better
```
----

```ts
type Vec3D = Record<'x' | 'y' | 'z', number>;
//   ^? type Vec3D = {
//        x: number;
//        y: number;
//        z: number;
//      }
```
----

```ts
declare function renderAButton(props: ButtonProps): void;
interface ButtonProps {
  title: string;
  onClick: () => void;
}

renderAButton({
  title: 'Roll the dice',
  onClick: () => alert(1 + Math.floor(6 * Math.random())),
  theme: 'Solarized',
// ~~~~ Object literal may only specify known properties…
});
```
----

```ts
interface ButtonProps {
  title: string;
  onClick: () => void;
  [otherProps: string]: unknown;
}

renderAButton({
  title: 'Roll the dice',
  onClick: () => alert(1 + Math.floor(20 * Math.random())),
  theme: 'Solarized',  // ok
});
```
---
effective-typescript-main/samples/ch-types/map-between-types.md
---
# Item 15: Use Type Operations and Generic Types to Avoid Repeating Yourself

## Things to Remember

- The DRY (don't repeat yourself) principle applies to types as much as it applies to logic.
- Name types rather than repeating them. Use `extends` to avoid repeating fields in interfaces.

[role="less_space pagebreak-before"]
- Build an understanding of the tools provided by TypeScript to map between types. These include `keyof`, `typeof`, indexing, and mapped types.
- Generic types are the equivalent of functions for types. Use them to map between types instead of repeating type-level operations.
- Familiarize yourself with generic types defined in the standard library, such as `Pick`, `Partial`, and `ReturnType`.
- Avoid over-application of DRY: make sure the properties and types you're sharing are really the same thing.


## Code Samples

```ts
console.log(
  'Cylinder r=1 × h=1',
  'Surface area:', 6.283185 * 1 * 1 + 6.283185 * 1 * 1,
  'Volume:', 3.14159 * 1 * 1 * 1
);
console.log(
  'Cylinder r=1 × h=2',
  'Surface area:', 6.283185 * 1 * 1 + 6.283185 * 2 * 1,
  'Volume:', 3.14159 * 1 * 2 * 1
);
console.log(
  'Cylinder r=2 × h=1',
  'Surface area:', 6.283185 * 2 * 1 + 6.283185 * 2 * 1,
  'Volume:', 3.14159 * 2 * 2 * 1
);
```
----

```ts
type CylinderFn = (r: number, h: number) => number;
const surfaceArea: CylinderFn = (r, h) => 2 * Math.PI * r * (r + h);
const volume: CylinderFn = (r, h) => Math.PI * r * r * h;

for (const [r, h] of [[1, 1], [1, 2], [2, 1]]) {
  console.log(
    `Cylinder r=${r} × h=${h}`,
    `Surface area: ${surfaceArea(r, h)}`,
    `Volume: ${volume(r, h)}`);
}
```
----

```ts
interface Person {
  firstName: string;
  lastName: string;
}

interface PersonWithBirthDate {
  firstName: string;
  lastName: string;
  birth: Date;
}
```
----

```ts
function distance(a: {x: number, y: number}, b: {x: number, y: number}) {
  return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
}
```
----

```ts
interface Point2D {
  x: number;
  y: number;
}
function distance(a: Point2D, b: Point2D) { /* ... */ }
```
----

```ts
function get(url: string, opts: Options): Promise<Response> { /* ... */ }
function post(url: string, opts: Options): Promise<Response> { /* ... */ }
```
----

```ts
type HTTPFunction = (url: string, opts: Options) => Promise<Response>;
const get: HTTPFunction = (url, opts) => { /* ... */ };
const post: HTTPFunction = (url, opts) => { /* ... */ };
```
----

```ts
interface Person {
  firstName: string;
  lastName: string;
}

interface PersonWithBirthDate extends Person {
  birth: Date;
}
```
----

```ts
interface Bird {
  wingspanCm: number;
  weightGrams: number;
  color: string;
  isNocturnal: boolean;
}
interface Mammal {
  weightGrams: number;
  color: string;
  isNocturnal: boolean;
  eatsGardenPlants: boolean;
}
```
----

```ts
interface Vertebrate {
  weightGrams: number;
  color: string;
  isNocturnal: boolean;
}
interface Bird extends Vertebrate {
  wingspanCm: number;
}
interface Mammal extends Vertebrate {
  eatsGardenPlants: boolean;
}
```
----

```ts
type PersonWithBirthDate = Person & { birth: Date };
```
----

```ts
interface State {
  userId: string;
  pageTitle: string;
  recentFiles: string[];
  pageContents: string;
}
interface TopNavState {
  userId: string;
  pageTitle: string;
  recentFiles: string[];
  // omits pageContents
}
```
----

```ts
interface TopNavState {
  userId: State['userId'];
  pageTitle: State['pageTitle'];
  recentFiles: State['recentFiles'];
};
```
----

```ts
type TopNavState = {
  [K in 'userId' | 'pageTitle' | 'recentFiles']: State[K]
};
```
----

```ts
type TopNavState = Pick<State, 'userId' | 'pageTitle' | 'recentFiles'>;
```
----

```ts
interface SaveAction {
  type: 'save';
  // ...
}
interface LoadAction {
  type: 'load';
  // ...
}
type Action = SaveAction | LoadAction;
type ActionType = 'save' | 'load';  // Repeated types!
```
----

```ts
type ActionType = Action['type'];
//   ^? type ActionType = "save" | "load"
```
----

```ts
type ActionRecord = Pick<Action, 'type'>;
//   ^? type ActionRecord = { type: "save" | "load"; }
```
----

```ts
interface Options {
  width: number;
  height: number;
  color: string;
  label: string;
}
interface OptionsUpdate {
  width?: number;
  height?: number;
  color?: string;
  label?: string;
}
class UIWidget {
  constructor(init: Options) { /* ... */ }
  update(options: OptionsUpdate) { /* ... */ }
}
```
----

```ts
type OptionsUpdate = {[k in keyof Options]?: Options[k]};
```
----

```ts
type OptionsKeys = keyof Options;
//   ^? type OptionsKeys = keyof Options
//      (equivalent to "width" | "height" | "color" | "label")
```
----

```ts
class UIWidget {
  constructor(init: Options) { /* ... */ }
  update(options: Partial<Options>) { /* ... */ }
}
```
----

```ts
interface ShortToLong {
  q: 'search';
  n: 'numberOfResults';
}
type LongToShort = { [k in keyof ShortToLong as ShortToLong[k]]: k };
//   ^? type LongToShort = { search: "q"; numberOfResults: "n"; }
```
----

```ts
interface Customer {
  /** How the customer would like to be addressed. */
  title?: string;
  /** Complete name as entered in the system. */
  readonly name: string;
}

type PickTitle = Pick<Customer, 'title'>;
//   ^? type PickTitle = { title?: string; }
type PickName = Pick<Customer, 'name'>;
//   ^? type PickName = { readonly name: string; }
type ManualName = { [K in 'name']: Customer[K]; };
//   ^? type ManualName = { name: string; }
```
----

```ts
type PartialNumber = Partial<number>;
//   ^? type PartialNumber = number
```
----

```ts
const INIT_OPTIONS = {
  width: 640,
  height: 480,
  color: '#00FF00',
  label: 'VGA',
};
interface Options {
  width: number;
  height: number;
  color: string;
  label: string;
}
```
----

```ts
type Options = typeof INIT_OPTIONS;
```
----

```ts
function getUserInfo(userId: string) {
  // ...
  return {
    userId,
    name,
    age,
    height,
    weight,
    favoriteColor,
  };
}
// Return type inferred as { userId: string; name: string; age: number, ... }
```
----

```ts
type UserInfo = ReturnType<typeof getUserInfo>;
```
----

```ts
interface Product {
  id: number;
  name: string;
  priceDollars: number;
}
interface Customer {
  id: number;
  name: string;
  address: string;
}
```
----

```ts
// Don't do this!
interface NamedAndIdentified {
  id: number;
  name: string;
}
interface Product extends NamedAndIdentified {
  priceDollars: number;
}
interface Customer extends NamedAndIdentified {
  address: string;
}
```
---
effective-typescript-main/samples/ch-types/readonly.md
---
# Item 14: Use readonly to Avoid Errors Associated with Mutation

## Things to Remember

- If your function does not modify its parameters, declare them `readonly` (arrays) or `Readonly` (object types). This makes the function's contract clearer and prevents inadvertent mutations in its implementation.
- Understand that `readonly` and `Readonly` are shallow, and that `Readonly` only affects properties, not methods.
- Use `readonly` to prevent errors with mutation and to find the places in your code where mutations occur.
- Understand the difference between `const` and `readonly`: the former prevents reassignment, the latter prevents mutation.
## Code Samples

```ts
function printTriangles(n: number) {
  const nums = [];
  for (let i = 0; i < n; i++) {
    nums.push(i);
    console.log(arraySum(nums));
  }
}
```
----

```ts
function arraySum(arr: number[]) {
  let sum = 0, num;
  while ((num = arr.pop()) !== undefined) {
    sum += num;
  }
  return sum;
}
```
----

```ts
interface PartlyMutableName {
  readonly first: string;
  last: string;
}

const jackie: PartlyMutableName = { first: 'Jacqueline', last: 'Kennedy' };
jackie.last = 'Onassis';  // OK
jackie.first = 'Jacky';
//     ~~~~~ Cannot assign to 'first' because it is a read-only property.
```
----

```ts
interface FullyMutableName {
  first: string;
  last: string;
}
type FullyImmutableName = Readonly<FullyMutableName>;
//   ^? type FullyImmutableName = {
//        readonly first: string;
//        readonly last: string;
//      }
```
----

```ts
interface Outer {
  inner: {
    x: number;
  }
}
const obj: Readonly<Outer> = { inner: { x: 0 }};
obj.inner = { x: 1 };
//  ~~~~~ Cannot assign to 'inner' because it is a read-only property
obj.inner.x = 1;  // OK
```
----

```ts
type T = Readonly<Outer>;
//   ^? type T = {
//        readonly inner: {
//          x: number;
//        };
//      }
```
----

```ts
const date: Readonly<Date> = new Date();
date.setFullYear(2037);  // OK, but mutates date!
```
----

```ts
interface Array<T> {
  length: number;
  // (non-mutating methods)
  toString(): string;
  join(separator?: string): string;
  // ...
  // (mutating methods)
  pop(): T | undefined;
  shift(): T | undefined;
  // ...
  [n: number]: T;
}
```
----

```ts
interface ReadonlyArray<T> {
  readonly length: number;
  // (non-mutating methods)
  toString(): string;
  join(separator?: string): string;
  // ...
  readonly [n: number]: T;
}
```
----

```ts
const a: number[] = [1, 2, 3];
const b: readonly number[] = a;
const c: number[] = b;
//    ~ Type 'readonly number[]' is 'readonly' and cannot be
//      assigned to the mutable type 'number[]'
```
----

```ts
function printTriangles(n: number) {
  const nums = [];
  for (let i = 0; i < n; i++) {
    nums.push(i);
    console.log(arraySum(nums as readonly number[]));
    //                   ~~~~~~~~~~~~~~~~~~~~~~~~~
    // The type 'readonly number[]' is 'readonly' and cannot be
    // assigned to the mutable type 'number[]'.
  }
}
```
----

```ts
function arraySum(arr: readonly number[]) {
  let sum = 0, num;
  while ((num = arr.pop()) !== undefined) {
    //              ~~~ 'pop' does not exist on type 'readonly number[]'
    sum += num;
  }
  return sum;
}
```
----

```ts
function arraySum(arr: readonly number[]) {
  let sum = 0;
  for (const num of arr) {
    sum += num;
  }
  return sum;
}
```
---
effective-typescript-main/samples/ch-types/type-entire-functions.md
---
# Item 12: Apply Types to Entire Function Expressions When Possible

## Things to Remember

- Consider applying type annotations to entire function expressions, rather than to their parameters and return type.
- If you're writing the same type signature repeatedly, factor out a function type or look for an existing one.
- If you're a library author, provide types for common callbacks.
- Use `typeof fn` to match the signature of another function, or `Parameters` and a rest parameter if you need to change the return type.


## Code Samples

```ts
function rollDice1(sides: number): number { /* ... */ }  // Statement
const rollDice2 = function(sides: number): number { /* ... */ };  // Expression
const rollDice3 = (sides: number): number => { /* ... */ };  // Also expression
```
----

```ts
type DiceRollFn = (sides: number) => number;
const rollDice: DiceRollFn = sides => { /* ... */ };
```
----

```ts
function add(a: number, b: number) { return a + b; }
function sub(a: number, b: number) { return a - b; }
function mul(a: number, b: number) { return a * b; }
function div(a: number, b: number) { return a / b; }
```
----

```ts
type BinaryFn = (a: number, b: number) => number;
const add: BinaryFn = (a, b) => a + b;
const sub: BinaryFn = (a, b) => a - b;
const mul: BinaryFn = (a, b) => a * b;
const div: BinaryFn = (a, b) => a / b;
```
----

```ts
const response = fetch('/quote?by=Mark+Twain');
//    ^? const response: Promise<Response>
```
----

```ts
async function getQuote() {
  const response = await fetch('/quote?by=Mark+Twain');
  const quote = await response.json();
  return quote;
}
// {
//   "quote": "If you tell the truth, you don't have to remember anything.",
//   "source": "notebook",
//   "date": "1894"
// }
```
----

```ts
declare function fetch(
  input: RequestInfo, init?: RequestInit,
): Promise<Response>;
```
----

```ts
async function checkedFetch(input: RequestInfo, init?: RequestInit) {
  const response = await fetch(input, init);
  if (!response.ok) {
    // An exception becomes a rejected Promise in an async function.
    throw new Error(`Request failed: ${response.status}`);
  }
  return response;
}
```
----

```ts
const checkedFetch: typeof fetch = async (input, init) => {
  const response = await fetch(input, init);
  if (!response.ok) {
    throw new Error(`Request failed: ${response.status}`);
  }
  return response;
}
```
----

```ts
const checkedFetch: typeof fetch = async (input, init) => {
  //  ~~~~~~~~~~~~
  //  'Promise<Response | HTTPError>' is not assignable to 'Promise<Response>'
  //    Type 'Response | HTTPError' is not assignable to type 'Response'
  const response = await fetch(input, init);
  if (!response.ok) {
    return new Error('Request failed: ' + response.status);
  }
  return response;
}
```
----

```ts
async function fetchANumber(
    ...args: Parameters<typeof fetch>
): Promise<number> {
  const response = await checkedFetch(...args);
  const num = Number(await response.text());
  if (isNaN(num)) {
    throw new Error(`Response was not a number.`);
  }
  return num;
}
```
----

```ts
fetchANumber
// ^? function fetchANumber(
//      input: RequestInfo | URL, init?: RequestInit | undefined
//    ): Promise<number>
```
---
effective-typescript-main/samples/ch-types/prefer-declarations-to-assertions.md
---
# Item 9: Prefer Type Annotations to Type Assertions

## Things to Remember

- Prefer type annotations (`: Type`) to type assertions (`as Type`).
- Know how to annotate the return type of an arrow function.
- Use type assertions and non-null assertions only when you know something about types that TypeScript does not.
- When you use a type assertion, include a comment explaining why it's valid.


## Code Samples

```ts
interface Person { name: string };

const alice: Person = { name: 'Alice' };
//    ^? const alice: Person
const bob = { name: 'Bob' } as Person;
//    ^? const bob: Person
```
----

```ts
const alice: Person = {};
//    ~~~~~ Property 'name' is missing in type '{}' but required in type 'Person'
const bob = {} as Person;  // No error
```
----

```ts
const alice: Person = {
  name: 'Alice',
  occupation: 'TypeScript developer'
// ~~~~~~~~~ Object literal may only specify known properties,
//           and 'occupation' does not exist in type 'Person'
};
const bob = {
  name: 'Bob',
  occupation: 'JavaScript developer'
} as Person;  // No error
```
----

```ts
const people = ['alice', 'bob', 'jan'].map(name => ({name}));
// { name: string; }[]... but we want Person[]
```
----

```ts
const people = ['alice', 'bob', 'jan'].map(
  name => ({name} as Person)
); // Type is Person[]
```
----

```ts
const people = ['alice', 'bob', 'jan'].map(name => ({} as Person));
// No error
```
----

```ts
const people = ['alice', 'bob', 'jan'].map(name => {
  const person: Person = {name};
  return person
}); // Type is Person[]
```
----

```ts
const people = ['alice', 'bob', 'jan'].map(
  (name): Person => ({name})
); // Type is Person[]
```
----

```ts
const people: Person[] = ['alice', 'bob', 'jan'].map(name => ({name})); // OK
```
----

```ts
document.querySelector('#myButton')?.addEventListener('click', e => {
  e.currentTarget
  // ^? (property) Event.currentTarget: EventTarget | null
  // currentTarget is #myButton is a button element
  const button = e.currentTarget as HTMLButtonElement;
  //    ^? const button: HTMLButtonElement
});
```
----

```ts
const elNull = document.getElementById('foo');
//    ^? const elNull: HTMLElement | null
const el = document.getElementById('foo') as HTMLElement;
//    ^? const el: HTMLElement
```
----

```ts
const el = document.getElementById('foo')!;
//    ^? const el: HTMLElement
```
----

```ts
document.getElementById('foo')?.addEventListener('click', () => {
  alert('Hi there!');
});
```
----

```ts
interface Person { name: string; }
const body = document.body;
const el = body as Person;
//         ~~~~~~~~~~~~~~
// Conversion of type 'HTMLElement' to type 'Person' may be a mistake because
// neither type sufficiently overlaps with the other. If this was intentional,
// convert the expression to 'unknown' first.
```
----

```ts
const el = document.body as unknown as Person;  // OK
```
---
effective-typescript-main/samples/ch-types/types-as-sets.md
---
# Item 7: Think of Types as Sets of Values

## Things to Remember

- Think of types as sets of values (the type's _domain_). These sets can either be finite (e.g., `boolean` or literal types) or infinite (e.g., `number` or `string`).
- TypeScript types form intersecting sets (a Venn diagram) rather than a strict hierarchy. Two types can overlap without either being a subtype of the other.
- Remember that an object can still belong to a type even if it has additional properties that were not mentioned in the type declaration.
- Type operations apply to a set's domain. The domain of `A | B` is the union of the domains of `A` and `B`.
- Think of "extends," "assignable to," and "subtype of" as synonyms for "subset of."

## Code Samples

```ts
const x: never = 12;
//    ~ Type 'number' is not assignable to type 'never'.
```
----

```ts
type A = 'A';
type B = 'B';
type Twelve = 12;
```
----

```ts
type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;
```
----

```ts
const a: AB = 'A';  // OK, value 'A' is a member of the set {'A', 'B'}
const c: AB = 'C';
//    ~ Type '"C"' is not assignable to type 'AB'
```
----

```ts
// OK, {"A", "B"} is a subset of {"A", "B"}:
const ab: AB = Math.random() < 0.5 ? 'A' : 'B';
const ab12: AB12 = ab;  // OK, {"A", "B"} is a subset of {"A", "B", 12}

declare let twelve: AB12;
const back: AB = twelve;
//    ~~~~ Type 'AB12' is not assignable to type 'AB'
//           Type '12' is not assignable to type 'AB'
```
----

```ts
type Int = 1 | 2 | 3 | 4 | 5 // | ...
```
----

```ts
interface Identified {
  id: string;
}
```
----

```ts
interface Person {
  name: string;
}
interface Lifespan {
  birth: Date;
  death?: Date;
}
type PersonSpan = Person & Lifespan;
```
----

```ts
const ps: PersonSpan = {
  name: 'Alan Turing',
  birth: new Date('1912/06/23'),
  death: new Date('1954/06/07'),
};  // OK
```
----

```ts
type K = keyof (Person | Lifespan);
//   ^? type K = never
```
----

```ts
interface Person {
  name: string;
}
interface PersonSpan extends Person {
  birth: Date;
  death?: Date;
}
```
----

```ts
interface NullyStudent {
  name: string;
  ageYears: number | null;
}
interface Student extends NullyStudent {
  ageYears: number;
}
```
----

```ts
interface StringyStudent extends NullyStudent {
  //      ~~~~~~~~~~~~~~
  // Interface 'StringyStudent' incorrectly extends interface 'NullyStudent'.
  ageYears: number | string;
}
```
----

```ts
interface Vector1D { x: number; }
interface Vector2D extends Vector1D { y: number; }
interface Vector3D extends Vector2D { z: number; }
```
----

```ts
interface Vector1D { x: number; }
interface Vector2D { x: number; y: number; }
interface Vector3D { x: number; y: number; z: number; }
```
----

```ts
function getKey<K extends string>(val: any, key: K) {
  // ...
}
```
----

```ts
getKey({}, 'x');  // OK, 'x' extends string
getKey({}, Math.random() < 0.5 ? 'a' : 'b');  // OK, 'a'|'b' extends string
getKey({}, document.title);  // OK, string extends string
getKey({}, 12);
//         ~~ Type 'number' is not assignable to parameter of type 'string'
```
----

```ts
const list = [1, 2];
//    ^? const list: number[]
const tuple: [number, number] = list;
//    ~~~~~ Type 'number[]' is not assignable to type '[number, number]'
//          Target requires 2 element(s) but source may have fewer
```
----

```ts
const triple: [number, number, number] = [1, 2, 3];
const double: [number, number] = triple;
//    ~~~~~~ '[number, number, number]' is not assignable to '[number, number]'
//           Source has 3 element(s) but target allows only 2.
```
----

```ts
type T = Exclude<string|Date, string|number>;
//   ^? type T = Date
type NonZeroNums = Exclude<number, 0>;
//   ^? type NonZeroNums = number
```
----

```ts
interface Lockbox {
  code: number;
}
interface ReadonlyLockbox {
  readonly code: number;
}
```
----

```ts
const box: Lockbox = { code: 4216 };
const robox: ReadonlyLockbox = { code: 3625 };
box.code = 1234;  // ok
robox.code = 1234;
//    ~~~~ Cannot assign to 'code' because it is a read-only property.
```
---
effective-typescript-main/samples/ch-types/avoid-object-wrapper-types.md
---
# Item 10: Avoid Object Wrapper Types (String, Number, Boolean, Symbol, BigInt)

## Things to Remember

- Avoid TypeScript object wrapper types. Use the primitive types instead: `string` instead of `String`, `number` instead of `Number`, `boolean` instead of `Boolean`, `symbol` instead of `Symbol`, and `bigint` instead of `BigInt`.
- Understand how object wrapper types are used to provide methods on primitive values. Avoid instantiating them or using them directly, with the exception of `Symbol` and `BigInt`.

## Code Samples

```js
// Don't do this!
const originalCharAt = String.prototype.charAt;
String.prototype.charAt = function(pos) {
  console.log(this, typeof this, pos);
  return originalCharAt.call(this, pos);
};
console.log('primitive'.charAt(3));
```
----

```ts
function getStringLen(foo: String) {
  return foo.length;
}

getStringLen("hello");  // OK
getStringLen(new String("hello"));  // OK
```
----

```ts
function isGreeting(phrase: String) {
  return ['hello', 'good day'].includes(phrase);
  //                                    ~~~~~~
  // Argument of type 'String' is not assignable to parameter of type 'string'.
  // 'string' is a primitive, but 'String' is a wrapper object.
  // Prefer using 'string' when possible.
}
```
----

```ts
const s: String = "primitive";
const n: Number = 12;
const b: Boolean = true;
```
---
effective-typescript-main/samples/ch-design/union-of-interfaces.md
---
# Item 34: Prefer Unions of Interfaces to Interfaces with Unions

## Things to Remember

- Interfaces with multiple properties that are union types are often a mistake because they obscure the relationships between these properties.
- Unions of interfaces are more precise and can be understood by TypeScript.
- Use tagged unions to facilitate control flow analysis. Because they are so well supported, this pattern is ubiquitous in TypeScript code.
- Consider whether multiple optional properties could be grouped to more accurately model your data.

## Code Samples

```ts
interface Layer {
  layout: FillLayout | LineLayout | PointLayout;
  paint: FillPaint | LinePaint | PointPaint;
}
```
----

```ts
interface FillLayer {
  layout: FillLayout;
  paint: FillPaint;
}
interface LineLayer {
  layout: LineLayout;
  paint: LinePaint;
}
interface PointLayer {
  layout: PointLayout;
  paint: PointPaint;
}
type Layer = FillLayer | LineLayer | PointLayer;
```
----

```ts
interface Layer {
  type: 'fill' | 'line' | 'point';
  layout: FillLayout | LineLayout | PointLayout;
  paint: FillPaint | LinePaint | PointPaint;
}
```
----

```ts
interface FillLayer {
  type: 'fill';
  layout: FillLayout;
  paint: FillPaint;
}
interface LineLayer {
  type: 'line';
  layout: LineLayout;
  paint: LinePaint;
}
interface PointLayer {
  type: 'paint';
  layout: PointLayout;
  paint: PointPaint;
}
type Layer = FillLayer | LineLayer | PointLayer;
```
----

```ts
function drawLayer(layer: Layer) {
  if (layer.type === 'fill') {
    const {paint} = layer;
    //     ^? const paint: FillPaint
    const {layout} = layer;
    //     ^? const layout: FillLayout
  } else if (layer.type === 'line') {
    const {paint} = layer;
    //     ^? const paint: LinePaint
    const {layout} = layer;
    //     ^? const layout: LineLayout
  } else {
    const {paint} = layer;
    //     ^? const paint: PointPaint
    const {layout} = layer;
    //     ^? const layout: PointLayout
  }
}
```
----

```ts
interface Person {
  name: string;
  // These will either both be present or not be present
  placeOfBirth?: string;
  dateOfBirth?: Date;
}
```
----

```ts
interface Person {
  name: string;
  birth?: {
    place: string;
    date: Date;
  }
}
```
----

```ts
const alanT: Person = {
  name: 'Alan Turing',
  birth: {
// ~~~~ Property 'date' is missing in type
//      '{ place: string; }' but required in type
//      '{ place: string; date: Date; }'
    place: 'London'
  }
}
```
----

```ts
function eulogize(person: Person) {
  console.log(person.name);
  const {birth} = person;
  if (birth) {
    console.log(`was born on ${birth.date} in ${birth.place}.`);
  }
}
```
----

```ts
interface Name {
  name: string;
}

interface PersonWithBirth extends Name {
  placeOfBirth: string;
  dateOfBirth: Date;
}

type Person = Name | PersonWithBirth;
```
----

```ts
function eulogize(person: Person) {
  if ('placeOfBirth' in person) {
    person
    // ^? (parameter) person: PersonWithBirth
    const {dateOfBirth} = person;  // OK
    //     ^? const dateOfBirth: Date
  }
}
```
---
effective-typescript-main/samples/ch-design/jsdoc-repeat.md
---
# Item 31: Don’t Repeat Type Information in Documentation

## Things to Remember

- Avoid repeating type information in comments and variable names. In the best case it is duplicative of type declarations, and in the worst case it will lead to conflicting information.
- Declare parameters `readonly` rather than saying that you don't mutate them.
- Consider including units in variable names if they aren't clear from the type (e.g., `timeMs` or `temperatureC`).

## Code Samples

```ts
/**
 * Returns a string with the foreground color.
 * Takes zero or one arguments. With no arguments, returns the
 * standard foreground color. With one argument, returns the foreground color
 * for a particular page.
 */
function getForegroundColor(page?: string) {
  return page === 'login' ? {r: 127, g: 127, b: 127} : {r: 0, g: 0, b: 0};
}
```
----

```ts
/** Get the foreground color for the application or a specific page. */
function getForegroundColor(page?: string): Color {
  // ...
}
```
----

```ts
/** Sort the strings by numeric value (i.e. "2" < "10"). Does not modify nums. */
function sortNumerically(nums: string[]): string[] {
  return nums.sort((a, b) => Number(a) - Number(b));
}
```
----

```ts
/** Sort the strings by numeric value (i.e. "2" < "10"). */
function sortNumerically(nums: readonly string[]): string[] {
  return nums.sort((a, b) => Number(a) - Number(b));
  //          ~~~~  ~  ~ Property 'sort' does not exist on 'readonly string[]'.
}
```
----

```ts
/** Sort the strings by numeric value (i.e. "2" < "10"). */
function sortNumerically(nums: readonly string[]): string[] {
  return nums.toSorted((a, b) => Number(a) - Number(b));  // ok
}
```
---
effective-typescript-main/samples/ch-design/incomplete-over-inaccurate.md
---
# Item 40: Prefer Imprecise Types to Inaccurate Types

## Things to Remember

- Avoid the uncanny valley of type safety: complex but inaccurate types are often worse than simpler, less precise types. If you cannot model a type accurately, do not model it inaccurately! Acknowledge the gaps using `any` or `unknown`.
- Pay attention to error messages and autocomplete as you make typings increasingly precise. It's not just about correctness: developer experience matters, too.
- As your types grow more complex, your test suite for them should expand.

## Code Samples

```ts
interface Point {
  type: 'Point';
  coordinates: number[];
}
interface LineString {
  type: 'LineString';
  coordinates: number[][];
}
interface Polygon {
  type: 'Polygon';
  coordinates: number[][][];
}
type Geometry = Point | LineString | Polygon;  // Also several others
```
----

```ts
type GeoPosition = [number, number];
interface Point {
  type: 'Point';
  coordinates: GeoPosition;
}
// Etc.
```
----

```ts
type Expression1 = any;
type Expression2 = number | string | any[];
```
----

```ts
const okExpressions: Expression2[] = [
  10,
  "red",
  ["+", 10, 5],
  ["rgb", 255, 128, 64],
  ["case", [">", 20, 10], "red", "blue"],
];
const invalidExpressions: Expression2[] = [
  true,
// ~~~ Type 'boolean' is not assignable to type 'Expression2'
  ["**", 2, 31],  // Should be an error: no "**" function
  ["rgb", 255, 0, 127, 0],  // Should be an error: too many values
  ["case", [">", 20, 10], "red", "blue", "green"],  // (Too many values)
];
```
----

```ts
type FnName = '+' | '-' | '*' | '/' | '>' | '<' | 'case' | 'rgb';
type CallExpression = [FnName, ...any[]];
type Expression3 = number | string | CallExpression;

const okExpressions: Expression3[] = [
  10,
  "red",
  ["+", 10, 5],
  ["rgb", 255, 128, 64],
  ["case", [">", 20, 10], "red", "blue"],
];
const invalidExpressions: Expression3[] = [
  true,
  // Error: Type 'boolean' is not assignable to type 'Expression3'
  ["**", 2, 31],
  // ~~ Type '"**"' is not assignable to type 'FnName'
  ["rgb", 255, 0, 127, 0],  // Should be an error: too many values
  ["case", [">", 20, 10], "red", "blue", "green"],  // (Too many values)
];
```
----

```ts
type Expression4 = number | string | CallExpression;

type CallExpression = MathCall | CaseCall | RGBCall;

type MathCall = [
  '+' | '-' | '/' | '*' | '>' | '<',
  Expression4,
  Expression4,
];

interface CaseCall {
  0: 'case';
  [n: number]: Expression4;
  length: 4 | 6 | 8 | 10 | 12 | 14 | 16; // etc.
}

type RGBCall = ['rgb', Expression4, Expression4, Expression4];
```
----

```ts
const okExpressions: Expression4[] = [
  10,
  "red",
  ["+", 10, 5],
  ["rgb", 255, 128, 64],
  ["case", [">", 20, 10], "red", "blue"],
];
const invalidExpressions: Expression4[] = [
  true,
// ~~~ Type 'boolean' is not assignable to type 'Expression4'
  ["**", 2, 31],
// ~~~~ Type '"**"' is not assignable to type '"+" | "-" | "/" | ...
  ["rgb", 255, 0, 127, 0],
  //                   ~ Type 'number' is not assignable to type 'undefined'.
  ["case", [">", 20, 10], "red", "blue", "green"],
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  // Types of property 'length' are incompatible.
  //    Type '5' is not assignable to type '4 | 6 | 8 | 10 | 12 | 14 | 16'.
];
```
----

```ts
const moreOkExpressions: Expression4[] = [
  ['-', 12],
  // ~~~~~~ Type '["-", number]' is not assignable to type 'MathCall'.
  //          Source has 2 element(s) but target requires 3.
  ['+', 1, 2, 3],
  //          ~ Type 'number' is not assignable to type 'undefined'.
  ['*', 2, 3, 4],
  //          ~ Type 'number' is not assignable to type 'undefined'.
];
```
---
effective-typescript-main/samples/ch-design/loose-accept-strict-produce.md
---
# Item 30: Be Liberal in What You Accept and Strict in What You Produce

## Things to Remember

- Input types tend to be broader than output types. Optional properties and union types are more common in parameter types than return types.
- Avoid broad return types since these will be awkward for clients to use.
- To reuse types between parameters and return types, introduce a canonical form (for return types) and a looser form (for parameters).
- Use `Iterable<T>` instead of `T[]` if you only need to iterate over your function parameter.

## Code Samples

```ts
declare function setCamera(camera: CameraOptions): void;
declare function viewportForBounds(bounds: LngLatBounds): CameraOptions;
```
----

```ts
interface CameraOptions {
  center?: LngLat;
  zoom?: number;
  bearing?: number;
  pitch?: number;
}
type LngLat =
  { lng: number; lat: number; } |
  { lon: number; lat: number; } |
  [number, number];
```
----

```ts
type LngLatBounds =
  {northeast: LngLat, southwest: LngLat} |
  [LngLat, LngLat] |
  [number, number, number, number];
```
----

```ts
function focusOnFeature(f: Feature) {
  const bounds = calculateBoundingBox(f); // helper function
  const camera = viewportForBounds(bounds);
  setCamera(camera);
  const {center: {lat, lng}, zoom} = camera;
               // ~~~      Property 'lat' does not exist on type ...
               //      ~~~ Property 'lng' does not exist on type ...
  zoom;
  // ^? const zoom: number | undefined
  window.location.search = `?v=@${lat},${lng}z${zoom}`;
}
```
----

```ts
interface LngLat { lng: number; lat: number; };
type LngLatLike = LngLat | { lon: number; lat: number; } | [number, number];

interface Camera {
  center: LngLat;
  zoom: number;
  bearing: number;
  pitch: number;
}
interface CameraOptions extends Omit<Partial<Camera>, 'center'> {
  center?: LngLatLike;
}
type LngLatBounds =
  {northeast: LngLatLike, southwest: LngLatLike} |
  [LngLatLike, LngLatLike] |
  [number, number, number, number];

declare function setCamera(camera: CameraOptions): void;
declare function viewportForBounds(bounds: LngLatBounds): Camera;
```
----

```ts
interface CameraOptions {
  center?: LngLatLike;
  zoom?: number;
  bearing?: number;
  pitch?: number;
}
```
----

```ts
function focusOnFeature(f: Feature) {
  const bounds = calculateBoundingBox(f);
  const camera = viewportForBounds(bounds);
  setCamera(camera);
  const {center: {lat, lng}, zoom} = camera;  // OK
  //                         ^? const zoom: number
  window.location.search = `?v=@${lat},${lng}z${zoom}`;
}
```
----

```ts
function sum(xs: number[]): number {
  let sum = 0;
  for (const x of xs) {
    sum += x;
  }
  return sum;
}
```
----

```ts
function sum(xs: Iterable<number>): number {
  let sum = 0;
  for (const x of xs) {
    sum += x;
  }
  return sum;
}
```
----

```ts
const six = sum([1, 2, 3]);
//    ^? const six: number
```
----

```ts
function* range(limit: number) {
  for (let i = 0; i < limit; i++) {
    yield i;
  }
}
const zeroToNine = range(10);
//    ^? const zeroToNine: Generator<number, void, unknown>
const fortyFive = sum(zeroToNine);  // ok, result is 45
```
---
effective-typescript-main/samples/ch-design/in-domain-null.md
---
# Item 36: Use a Distinct Type for Special Values

## Things to Remember

- Avoid special values that are assignable to regular values in a type. They will reduce TypeScript's ability to find bugs in your code.
- Prefer `null` or `undefined` as a special value instead of `0`, `-1`, or `""`.
- Consider using a tagged union rather than `null` or `undefined` if the meaning of those values isn't clear.

## Code Samples

```ts
function splitAround<T>(vals: readonly T[], val: T): [T[], T[]] {
  const index = vals.indexOf(val);
  return [vals.slice(0, index), vals.slice(index+1)];
}
```
----

```ts
function safeIndexOf<T>(vals: readonly T[], val: T): number | null {
  const index = vals.indexOf(val);
  return index === -1 ? null : index;
}
```
----

```ts
function splitAround<T>(vals: readonly T[], val: T): [T[], T[]] {
  const index = safeIndexOf(vals, val);
  return [vals.slice(0, index), vals.slice(index+1)];
  //                    ~~~~~              ~~~~~ 'index' is possibly 'null'
}
```
----

```ts
function splitAround<T>(vals: readonly T[], val: T): [T[], T[]] {
  const index = safeIndexOf(vals, val);
  if (index === null) {
    return [[...vals], []];
  }
  return [vals.slice(0, index), vals.slice(index+1)];  // ok
}
```
----

```ts
interface Product {
  title: string;
  priceDollars: number;
}
```
----

```ts
interface Product {
  title: string;
  /** Price of the product in dollars, or -1 if price is unknown */
  priceDollars: number;
}
```
----

```ts
// @strictNullChecks: false
const truck: Product = {
  title: 'Tesla Cybertruck',
  priceDollars: null,  // ok
};
```
---
effective-typescript-main/samples/ch-design/avoid-strings.md
---
# Item 35: Prefer More Precise Alternatives to String Types

## Things to Remember

- Avoid "stringly typed" code. Prefer more appropriate types where not every `string` is a possibility.
- Prefer a union of string literal types to `string` if that more accurately describes the domain of a variable. You'll get stricter type checking and improve the development experience.
- Prefer `keyof T` to `string` for function parameters that are expected to be properties of an object.

## Code Samples

```ts
interface Album {
  artist: string;
  title: string;
  releaseDate: string;  // YYYY-MM-DD
  recordingType: string;  // E.g., "live" or "studio"
}
```
----

```ts
const kindOfBlue: Album = {
  artist: 'Miles Davis',
  title: 'Kind of Blue',
  releaseDate: 'August 17th, 1959',  // Oops!
  recordingType: 'Studio',  // Oops!
};  // OK
```
----

```ts
function recordRelease(title: string, date: string) { /* ... */ }
recordRelease(kindOfBlue.releaseDate, kindOfBlue.title);  // OK, should be error
```
----

```ts
type RecordingType = 'studio' | 'live';

interface Album {
  artist: string;
  title: string;
  releaseDate: Date;
  recordingType: RecordingType;
}
```
----

```ts
const kindOfBlue: Album = {
  artist: 'Miles Davis',
  title: 'Kind of Blue',
  releaseDate: new Date('1959-08-17'),
  recordingType: 'Studio'
// ~~~~~~~~~~~~ Type '"Studio"' is not assignable to type 'RecordingType'
};
```
----

```ts
function getAlbumsOfType(recordingType: string): Album[] {
  // ...
}
```
----

```ts
/** What type of environment was this recording made in? */
type RecordingType = 'live' | 'studio';
```
----

```js
function pluck(records, key) {
  return records.map(r => r[key]);
}
```
----

```ts
function pluck(records: any[], key: string): any[] {
  return records.map(r => r[key]);
}
```
----

```ts
function pluck<T>(records: T[], key: string): any[] {
  return records.map(r => r[key]);
  //                      ~~~~~~ Element implicitly has an 'any' type
  //                             because type '{}' has no index signature
}
```
----

```ts
type K = keyof Album;
//   ^? type K = keyof Album
//      (equivalent to "artist" | "title" | "releaseDate" | "recordingType")
```
----

```ts
function pluck<T>(records: T[], key: keyof T) {
  return records.map(r => r[key]);
}
```
----

```ts
const releaseDates = pluck(albums, 'releaseDate');
//    ^? const releaseDates: (string | Date)[]
```
----

```ts
function pluck<T, K extends keyof T>(records: T[], key: K): T[K][] {
  return records.map(r => r[key]);
}
```
----

```ts
const dates = pluck(albums, 'releaseDate');
//    ^? const dates: Date[]
const artists = pluck(albums, 'artist');
//    ^? const artists: string[]
const types = pluck(albums, 'recordingType');
//    ^? const types: RecordingType[]
const mix = pluck(albums, Math.random() < 0.5 ? 'releaseDate' : 'artist');
//    ^? const mix: (string | Date)[]
const badDates = pluck(albums, 'recordingDate');
//                             ~~~~~~~~~~~~~~~
// Argument of type '"recordingDate"' is not assignable to parameter of type ...
```
---
effective-typescript-main/samples/ch-design/valid-states.md
---
# Item 29: Prefer Types That Always Represent Valid States

## Things to Remember

- Types that represent both valid and invalid states are likely to lead to confusing and error-prone code.
- Prefer types that only represent valid states. Even if they are longer or harder to express, they will save you time and pain in the end!

## Code Samples

```ts
interface State {
  pageText: string;
  isLoading: boolean;
  error?: string;
}
```
----

```ts
function renderPage(state: State) {
  if (state.error) {
    return `Error! Unable to load ${currentPage}: ${state.error}`;
  } else if (state.isLoading) {
    return `Loading ${currentPage}...`;
  }
  return `<h1>${currentPage}</h1>\n${state.pageText}`;
}
```
----

```ts
async function changePage(state: State, newPage: string) {
  state.isLoading = true;
  try {
    const response = await fetch(getUrlForPage(newPage));
    if (!response.ok) {
      throw new Error(`Unable to load ${newPage}: ${response.statusText}`);
    }
    const text = await response.text();
    state.isLoading = false;
    state.pageText = text;
  } catch (e) {
    state.error = '' + e;
  }
}
```
----

```ts
interface RequestPending {
  state: 'pending';
}
interface RequestError {
  state: 'error';
  error: string;
}
interface RequestSuccess {
  state: 'ok';
  pageText: string;
}
type RequestState = RequestPending | RequestError | RequestSuccess;

interface State {
  currentPage: string;
  requests: {[page: string]: RequestState};
}
```
----

```ts
function renderPage(state: State) {
  const {currentPage} = state;
  const requestState = state.requests[currentPage];
  switch (requestState.state) {
    case 'pending':
      return `Loading ${currentPage}...`;
    case 'error':
      return `Error! Unable to load ${currentPage}: ${requestState.error}`;
    case 'ok':
      return `<h1>${currentPage}</h1>\n${requestState.pageText}`;
  }
}

async function changePage(state: State, newPage: string) {
  state.requests[newPage] = {state: 'pending'};
  state.currentPage = newPage;
  try {
    const response = await fetch(getUrlForPage(newPage));
    if (!response.ok) {
      throw new Error(`Unable to load ${newPage}: ${response.statusText}`);
    }
    const pageText = await response.text();
    state.requests[newPage] = {state: 'ok', pageText};
  } catch (e) {
    state.requests[newPage] = {state: 'error', error: '' + e};
  }
}
```
----

```ts
interface CockpitControls {
  /** Angle of the left side stick in degrees, 0 = neutral, + = forward */
  leftSideStick: number;
  /** Angle of the right side stick in degrees, 0 = neutral, + = forward */
  rightSideStick: number;
}
```
----

```ts
function getStickSetting(controls: CockpitControls) {
  return controls.leftSideStick;
}
```
----

```ts
function getStickSetting(controls: CockpitControls) {
  const {leftSideStick, rightSideStick} = controls;
  if (leftSideStick === 0) {
    return rightSideStick;
  }
  return leftSideStick;
}
```
----

```ts
function getStickSetting(controls: CockpitControls) {
  const {leftSideStick, rightSideStick} = controls;
  if (leftSideStick === 0) {
    return rightSideStick;
  } else if (rightSideStick === 0) {
    return leftSideStick;
  }
  // ???
}
```
----

```ts
function getStickSetting(controls: CockpitControls) {
  const {leftSideStick, rightSideStick} = controls;
  if (leftSideStick === 0) {
    return rightSideStick;
  } else if (rightSideStick === 0) {
    return leftSideStick;
  }
  if (Math.abs(leftSideStick - rightSideStick) < 5) {
    return (leftSideStick + rightSideStick) / 2;
  }
  // ???
}
```
----

```ts
function getStickSetting(controls: CockpitControls) {
  return (controls.leftSideStick + controls.rightSideStick) / 2;
}
```
----

```ts
interface CockpitControls {
  /** Angle of the stick in degrees, 0 = neutral, + = forward */
  stickAngle: number;
}
```
---
effective-typescript-main/samples/ch-design/same-type-params.md
---
# Item 38: Avoid Repeated Parameters of the Same Type

## Things to Remember

- Avoid writing functions that take consecutive parameters with the same TypeScript type.
- Refactor functions that take many parameters to take fewer parameters with distinct types, or a single object parameter.


## Code Samples

```ts
drawRect(25, 50, 75, 100, 1);
```
----

```ts
function drawRect(x: number, y: number, w: number, h: number, opacity: number) {
  // ...
}
```
----

```ts
interface Point {
  x: number;
  y: number;
}
interface Dimension {
  width: number;
  height: number;
}
function drawRect(topLeft: Point, size: Dimension, opacity: number) {
  // ...
}
```
----

```ts
drawRect({x: 25, y: 50}, {x: 75, y: 100}, 1.0);
//                        ~
// Argument ... is not assignable to parameter of type 'Dimension'.
```
----

```ts
interface DrawRectParams extends Point, Dimension {
  opacity: number;
}
function drawRect(params: DrawRectParams) { /* ... */ }

drawRect({x: 25, y: 50, width: 75, height: 100, opacity: 1.0});
```
---
effective-typescript-main/samples/ch-design/avoid-optional.md
---
# Item 37: Limit the Use of Optional Properties

## Things to Remember

- Optional properties can prevent the type checker from finding bugs and can lead to repeated and possibly inconsistent code for filling in default values.
- Think twice before adding an optional property to an interface. Consider whether you could make it required instead.
- Consider creating distinct types for un-normalized input data and normalized data for use in your code.
- Avoid a combinatorial explosion of options.

## Code Samples

```ts
interface FormattedValue {
  value: number;
  units: string;
}
function formatValue(value: FormattedValue) { /* ... */ }
```
----

```ts
interface Hike {
  miles: number;
  hours: number;
}
function formatHike({miles, hours}: Hike) {
  const distanceDisplay = formatValue({value: miles, units: 'miles'});
  const paceDisplay = formatValue({value: miles / hours, units: 'mph'});
  return `${distanceDisplay} at ${paceDisplay}`;
}
```
----

```ts
type UnitSystem = 'metric' | 'imperial';
interface FormattedValue {
  value: number;
  units: string;
  /** default is imperial */
  unitSystem?: UnitSystem;
}
```
----

```ts
interface AppConfig {
  darkMode: boolean;
  // ... other settings ...
  /** default is imperial */
  unitSystem?: UnitSystem;
}
```
----

```ts
function formatHike({miles, hours}: Hike, config: AppConfig) {
  const { unitSystem } = config;
  const distanceDisplay = formatValue({
    value: miles, units: 'miles', unitSystem
  });
  const paceDisplay = formatValue({
    value: miles / hours, units: 'mph'  // forgot unitSystem, oops!
  });
  return `${distanceDisplay} at ${paceDisplay}`;
}
```
----

```ts
declare let config: AppConfig;
const unitSystem = config.unitSystem ?? 'imperial';
```
----

```ts
const unitSystem = config.unitSystem ?? 'metric';
```
----

```ts
interface InputAppConfig {
  darkMode: boolean;
  // ... other settings ...
  /** default is imperial */
  unitSystem?: UnitSystem;
}
interface AppConfig extends InputAppConfig {
  unitSystem: UnitSystem;  // required
}
```
----

```ts
function normalizeAppConfig(inputConfig: InputAppConfig): AppConfig {
  return {
    ...inputConfig,
    unitSystem: inputConfig.unitSystem ?? 'imperial',
  };
}
```
---
effective-typescript-main/samples/ch-design/consider-codegen.md
---
# Item 42: Avoid Types Based on Anecdotal Data

## Things to Remember

- Avoid writing types by hand based on data that you've seen. It's easy to misunderstand a schema or get nullability wrong.
- Prefer types sourced from official clients or the community. If these don't exist, generate TypeScript types from schemas.## Code Samples

```ts
function calculateBoundingBox(f: GeoJSONFeature): BoundingBox | null {
  let box: BoundingBox | null = null;

  const helper = (coords: any[]) => {
    // ...
  };

  const {geometry} = f;
  if (geometry) {
    helper(geometry.coordinates);
  }

  return box;
}
```
----

```ts
interface GeoJSONFeature {
  type: 'Feature';
  geometry: GeoJSONGeometry | null;
  properties: unknown;
}
interface GeoJSONGeometry {
  type: 'Point' | 'LineString' | 'Polygon' | 'MultiPolygon';
  coordinates: number[] | number[][] | number[][][] | number[][][][];
}
```
----

```ts
import {Feature} from 'geojson';

function calculateBoundingBox(f: Feature): BoundingBox | null {
  let box: BoundingBox | null = null;

  const helper = (coords: any[]) => {
    // ...
  };

  const {geometry} = f;
  if (geometry) {
    helper(geometry.coordinates);
    //              ~~~~~~~~~~~
    //   Property 'coordinates' does not exist on type 'Geometry'
    //     Property 'coordinates' does not exist on type 'GeometryCollection'
  }

  return box;
}
```
----

```ts
const {geometry} = f;
if (geometry) {
  if (geometry.type === 'GeometryCollection') {
    throw new Error('GeometryCollections are not supported.');
  }
  helper(geometry.coordinates);  // OK
}
```
----

```ts
const geometryHelper = (g: Geometry) => {
  if (g.type === 'GeometryCollection') {
    g.geometries.forEach(geometryHelper);
  } else {
    helper(g.coordinates);  // OK
  }
}

const {geometry} = f;
if (geometry) {
  geometryHelper(geometry);
}
```
---
effective-typescript-main/samples/ch-design/language-of-domain.md
---
# Item 41: Name Types Using the Language of Your Problem Domain

## Things to Remember

- Reuse names from the domain of your problem where possible to increase the readability and level of abstraction of your code. Make sure you use domain terms accurately.
- Avoid using different names for the same thing: make distinctions in names meaningful.
- Avoid vague names like "Info" or "Entity." Name types for what they are, rather than for their shape.

## Code Samples

```ts
interface Animal {
  name: string;
  endangered: boolean;
  habitat: string;
}

const leopard: Animal = {
  name: 'Snow Leopard',
  endangered: false,
  habitat: 'tundra',
};
```
----

```ts
interface Animal {
  commonName: string;
  genus: string;
  species: string;
  status: ConservationStatus;
  climates: KoppenClimate[];
}
type ConservationStatus = 'EX' | 'EW' | 'CR' | 'EN' | 'VU' | 'NT' | 'LC';
type KoppenClimate = |
  'Af' | 'Am' | 'As' | 'Aw' |
  'BSh' | 'BSk' | 'BWh' | 'BWk' |
  'Cfa' | 'Cfb' | 'Cfc' | 'Csa' | 'Csb' | 'Csc' | 'Cwa' | 'Cwb' | 'Cwc' |
  'Dfa' | 'Dfb' | 'Dfc' | 'Dfd' |
  'Dsa' | 'Dsb' | 'Dsc' | 'Dwa' | 'Dwb' | 'Dwc' | 'Dwd' |
  'EF' | 'ET';
const snowLeopard: Animal = {
  commonName: 'Snow Leopard',
  genus: 'Panthera',
  species: 'Uncia',
  status: 'VU',  // vulnerable
  climates: ['ET', 'EF', 'Dfd'],  // alpine or subalpine
};
```
---
effective-typescript-main/samples/ch-design/null-in-type.md
---
# Item 32: Avoid Including null or undefined in Type Aliases

## Things to Remember

- Avoid defining type aliases that include `null` or `undefined`.

## Code Samples

```ts
function getCommentsForUser(comments: readonly Comment[], user: User) {
  return comments.filter(comment => comment.userId === user?.id);
}
```
----

```ts
type User = { id: string; name: string; } | null;
```
----

```ts
interface User {
  id: string;
  name: string;
}
```
----

```ts
type NullableUser = { id: string; name: string; } | null;
```
----

```ts
function getCommentsForUser(comments: readonly Comment[], user: User | null) {
  return comments.filter(comment => comment.userId === user?.id);
}
```
----

```ts
type BirthdayMap = {
  [name: string]: Date | undefined;
};
```
----

```ts
type BirthdayMap = {
  [name: string]: Date | undefined;
} | null;
```
---
effective-typescript-main/samples/ch-design/null-values-to-perimeter.md
---
# Item 33: Push Null Values to the Perimeter of Your Types

## Things to Remember

- Avoid designs in which one value being `null` or not `null` is implicitly related to another value being `null` or not `null`.
- Push `null` values to the perimeter of your API by making larger objects either `null` or fully non-`null`. This will make code clearer both for human readers and for the type checker.
- Consider creating a fully non-`null` class and constructing it when all values are available.

## Code Samples

```ts
// @strictNullChecks: false
function extent(nums: Iterable<number>) {
  let min, max;
  for (const num of nums) {
    if (!min) {
      min = num;
      max = num;
    } else {
      min = Math.min(min, num);
      max = Math.max(max, num);
    }
  }
  return [min, max];
}
```
----

```ts
function extent(nums: Iterable<number>) {
  let min, max;
  for (const num of nums) {
    if (!min) {
      min = num;
      max = num;
    } else {
      min = Math.min(min, num);
      max = Math.max(max, num);
      //             ~~~ Argument of type 'number | undefined' is not
      //                 assignable to parameter of type 'number'
    }
  }
  return [min, max];
}
```
----

```ts
const [min, max] = extent([0, 1, 2]);
const span = max - min;
//           ~~~   ~~~ Object is possibly 'undefined'
```
----

```ts
function extent(nums: Iterable<number>) {
  let minMax: [number, number] | null = null;
  for (const num of nums) {
    if (!minMax) {
      minMax = [num, num];
    } else {
      const [oldMin, oldMax] = minMax;
      minMax = [Math.min(num, oldMin), Math.max(num, oldMax)];
    }
  }
  return minMax;
}
```
----

```ts
const [min, max] = extent([0, 1, 2])!;
const span = max - min;  // OK
```
----

```ts
const range = extent([0, 1, 2]);
if (range) {
  const [min, max] = range;
  const span = max - min;  // OK
}
```
----

```ts
class UserPosts {
  user: UserInfo | null;
  posts: Post[] | null;

  constructor() {
    this.user = null;
    this.posts = null;
  }

  async init(userId: string) {
    return Promise.all([
      async () => this.user = await fetchUser(userId),
      async () => this.posts = await fetchPostsForUser(userId)
    ]);
  }

  getUserName() {
    // ...?
  }
}
```
----

```ts
class UserPosts {
  user: UserInfo;
  posts: Post[];

  constructor(user: UserInfo, posts: Post[]) {
    this.user = user;
    this.posts = posts;
  }

  static async init(userId: string): Promise<UserPosts> {
    const [user, posts] = await Promise.all([
      fetchUser(userId),
      fetchPostsForUser(userId)
    ]);
    return new UserPosts(user, posts);
  }

  getUserName() {
    return this.user.name;
  }
}
```
---
effective-typescript-main/samples/ch-design/unify.md
---
# Item 39: Prefer Unifying Types to Modeling Differences

## Things to Remember

- Having distinct variants of the same type creates cognitive overhead and requires lots of conversion code.
- Rather than modeling slight variations on a type in your code, try to eliminate the variation so that you can unify to a single type.
- Unifying types may require some adjustments to runtime code.
- If the types aren't in your control, you may need to model the variations.
- Don't unify types that aren't representing the same thing.

////## Code Samples

```ts
interface StudentTable {
  first_name: string;
  last_name: string;
  birth_date: string;
}
```
----

```ts
interface Student {
  firstName: string;
  lastName: string;
  birthDate: string;
}
```
----

```ts
type Student = ObjectToCamel<StudentTable>;
//   ^? type Student = {
//        firstName: string;
//        lastName: string;
//        birthDate: string;
//      }
```
----

```ts
async function writeStudentToDb(student: Student) {
  await writeRowToDb(db, 'students', student);
  //                                 ~~~~~~~
  // Type 'Student' is not assignable to parameter of type 'StudentTable'.
}
```
----

```ts
async function writeStudentToDb(student: Student) {
  await writeRowToDb(db, 'students', objectToSnake(student));  // ok
}
```
---
effective-typescript-main/samples/ch-intro/which-ts.md
---
# Item 2: Know Which TypeScript Options You're Using

## Things to Remember

- The TypeScript compiler includes several settings that affect core aspects of the language.
- Configure TypeScript using _tsconfig.json_ rather than command-line options.
- Turn on `noImplicitAny` unless you are transitioning a JavaScript project to TypeScript.
- Use `strictNullChecks` to prevent "undefined is not an object”-style runtime errors.
- Aim to enable `strict` to get the most thorough checking that TypeScript can offer.


## Code Samples

```ts
function add(a, b) {
  return a + b;
}
add(10, null);
```
----

```ts
function add(a, b) {
  return a + b;
}
```
----

```ts
function add(a, b) {
  //         ~    Parameter 'a' implicitly has an 'any' type
  //            ~ Parameter 'b' implicitly has an 'any' type
  return a + b;
}
```
----

```ts
function add(a: number, b: number) {
  return a + b;
}
```
----

```ts
const x: number = null;  // OK, null is a valid number
```
----

```ts
const x: number = null;
//    ~ Type 'null' is not assignable to type 'number'
```
----

```ts
const x: number | null = null;
```
----

```ts
const statusEl = document.getElementById('status');
statusEl.textContent = 'Ready';
// ~~~~~ 'statusEl' is possibly 'null'.

if (statusEl) {
  statusEl.textContent = 'Ready';  // OK, null has been excluded
}
statusEl!.textContent = 'Ready';  // OK, we've asserted that el is non-null
```
----

```ts
const tenses = ['past', 'present', 'future'];
tenses[3].toUpperCase();
```
----

```ts
const tenses = ['past', 'present', 'future'];
tenses[3].toUpperCase();
// ~~~~~~ Object is possibly 'undefined'.
```
----

```ts
tenses[0].toUpperCase();
// ~~~~~~ Object is possibly 'undefined'.
```
---
effective-typescript-main/samples/ch-intro/ts-vs-js.md
---
# Item 1: Understand the Relationship Between TypeScript and JavaScript

## Things to Remember

- TypeScript is a superset of JavaScript: all JavaScript programs are syntactically valid TypeScript programs, but not all TypeScript programs are valid JavaScript programs.
- TypeScript adds a static type system that models JavaScript's runtime behavior and tries to spot code that will throw exceptions at runtime.
- It is possible for code to pass the type checker but still throw at runtime.
- TypeScript disallows some legal but questionable JavaScript constructs such as calling functions with the wrong number of arguments.
- Type annotations tell TypeScript your intent and help it distinguish correct and incorrect code.
## Code Samples

```ts
function greet(who: string) {
  console.log('Hello', who);
}
```
----

```js
let city = 'new york city';
console.log(city.toUppercase());
```
----

```ts
let city = 'new york city';
console.log(city.toUppercase());
//               ~~~~~~~~~~~ Property 'toUppercase' does not exist on type
//                           'string'. Did you mean 'toUpperCase'?
```
----

```js
const states = [
  {name: 'Alabama', capital: 'Montgomery'},
  {name: 'Alaska',  capital: 'Juneau'},
  {name: 'Arizona', capital: 'Phoenix'},
  // ...
];
for (const state of states) {
  console.log(state.capitol);
}
```
----

```ts
for (const state of states) {
  console.log(state.capitol);
  //                ~~~~~~~ Property 'capitol' does not exist on type
  //                        '{ name: string; capital: string; }'.
  //                        Did you mean 'capital'?
}
```
----

```ts
const states = [
  {name: 'Alabama', capitol: 'Montgomery'},
  {name: 'Alaska',  capitol: 'Juneau'},
  {name: 'Arizona', capitol: 'Phoenix'},
  // ...
];
for (const state of states) {
  console.log(state.capital);
  //                ~~~~~~~ Property 'capital' does not exist on type
  //                        '{ name: string; capitol: string; }'.
  //                        Did you mean 'capitol'?
}
```
----

```ts
interface State {
  name: string;
  capital: string;
}
const states: State[] = [
  {name: 'Alabama', capitol: 'Montgomery'},
  //                ~~~~~~~
  {name: 'Alaska',  capitol: 'Juneau'},
  //                ~~~~~~~
  {name: 'Arizona', capitol: 'Phoenix'},
  //                ~~~~~~~ Object literal may only specify known properties,
  //                        but 'capitol' does not exist in type 'State'.
  //                        Did you mean to write 'capital'?
  // ...
];
for (const state of states) {
  console.log(state.capital);
}
```
----

```ts
const states: State[] = [
  {name: 'Alabama', capital: 'Montgomery'},
  {name: 'Alaska',  capitol: 'Juneau'},
  //                ~~~~~~~ Did you mean to write 'capital'?
  {name: 'Arizona', capital: 'Phoenix'},
  // ...
];
```
----

```ts
const x = 2 + '3';  // OK
//    ^? const x: string
const y = '2' + 3;  // OK
//    ^? const y: string
```
----

```ts
const a = null + 7;  // Evaluates to 7 in JS
//        ~~~~ The value 'null' cannot be used here.
const b = [] + 12;  // Evaluates to '12' in JS
//        ~~~~~~~ Operator '+' cannot be applied to types ...
alert('Hello', 'TypeScript');  // alerts "Hello"
//             ~~~~~~~~~~~~ Expected 0-1 arguments, but got 2
```
----

```ts
const names = ['Alice', 'Bob'];
console.log(names[2].toUpperCase());
```
---
effective-typescript-main/samples/ch-intro/any.md
---
# Item 5: Limit Use of the any Type

## Things to Remember

- TypeScript's `any` type allows you to disable most forms of type checking for a symbol.
- The `any` type eliminates type safety, lets you break contracts, harms developer experience, makes refactoring error prone, hides your type design, and undermines confidence in the type system.
- Avoid using `any` when you can!
## Code Samples

```ts
let ageInYears: number;
ageInYears = '12';
// ~~~~~~~ Type 'string' is not assignable to type 'number'.
ageInYears = '12' as any;  // OK
```
----

```ts
ageInYears += 1;  // OK; at runtime, ageInYears is now "121"
```
----

```ts
function calculateAge(birthDate: Date): number {
  // ...
}

let birthDate: any = '1990-01-19';
calculateAge(birthDate);  // OK
```
----

```ts
interface Person {
  first: string;
  last: string;
}

const formatName = (p: Person) => `${p.first} ${p.last}`;
const formatNameAny = (p: any) => `${p.first} ${p.last}`;
```
----

```ts
interface Person {
  firstName: string;
  last: string;
}
const formatName = (p: Person) => `${p.firstName} ${p.last}`;
const formatNameAny = (p: any) => `${p.first} ${p.last}`;
```
----

```ts
interface ComponentProps {
  onSelectItem: (item: any) => void;
}
```
----

```ts
function renderSelector(props: ComponentProps) { /* ... */ }

let selectedId: number = 0;
function handleSelectItem(item: any) {
  selectedId = item.id;
}

renderSelector({onSelectItem: handleSelectItem});
```
----

```ts
interface ComponentProps {
  onSelectItem: (id: number) => void;
}
```
---
effective-typescript-main/samples/ch-intro/structural.md
---
# Item 4: Get Comfortable with Structural Typing

## Things to Remember

- Understand that JavaScript is duck typed and TypeScript uses structural typing to model this: values assignable to your interfaces might have properties beyond those explicitly listed in your type declarations. Types are not "sealed."
- Be aware that classes also follow structural typing rules. You may not have an instance of the class you expect!
- Use structural typing to facilitate unit testing.


## Code Samples

```ts
interface Vector2D {
  x: number;
  y: number;
}
```
----

```ts
function calculateLength(v: Vector2D) {
  return Math.sqrt(v.x ** 2 + v.y ** 2);
}
```
----

```ts
interface NamedVector {
  name: string;
  x: number;
  y: number;
}
```
----

```ts
const v: NamedVector = { x: 3, y: 4, name: 'Pythagoras' };
calculateLength(v);  // OK, result is 5
```
----

```ts
interface Vector3D {
  x: number;
  y: number;
  z: number;
}
```
----

```ts
function normalize(v: Vector3D) {
  const length = calculateLength(v);
  return {
    x: v.x / length,
    y: v.y / length,
    z: v.z / length,
  };
}
```
----

```ts
function calculateLengthL1(v: Vector3D) {
  let length = 0;
  for (const axis of Object.keys(v)) {
    const coord = v[axis];
    //            ~~~~~~~ Element implicitly has an 'any' type because ...
    //                    'string' can't be used to index type 'Vector3D'
    length += Math.abs(coord);
  }
  return length;
}
```
----

```ts
const vec3D = {x: 3, y: 4, z: 1, address: '123 Broadway'};
calculateLengthL1(vec3D);  // OK, returns NaN
```
----

```ts
function calculateLengthL1(v: Vector3D) {
  return Math.abs(v.x) + Math.abs(v.y) + Math.abs(v.z);
}
```
----

```ts
class SmallNumContainer {
  num: number;
  constructor(num: number) {
    if (num < 0 || num >= 10) {
      throw new Error(`You gave me ${num} but I want something 0-9.`)
    }
    this.num = num;
  }
}

const a = new SmallNumContainer(5);
const b: SmallNumContainer = { num: 2024 };  // OK!
```
----

```ts
interface Author {
  first: string;
  last: string;
}
function getAuthors(database: PostgresDB): Author[] {
  const authorRows = database.runQuery(`SELECT first, last FROM authors`);
  return authorRows.map(row => ({first: row[0], last: row[1]}));
}
```
----

```ts
interface DB {
  runQuery: (sql: string) => any[];
}
function getAuthors(database: DB): Author[] {
  const authorRows = database.runQuery(`SELECT first, last FROM authors`);
  return authorRows.map(row => ({first: row[0], last: row[1]}));
}
```
----

```ts
test('getAuthors', () => {
  const authors = getAuthors({
    runQuery(sql: string) {
      return [['Toni', 'Morrison'], ['Maya', 'Angelou']];
    }
  });
  expect(authors).toEqual([
    {first: 'Toni', last: 'Morrison'},
    {first: 'Maya', last: 'Angelou'}
  ]);
});
```
---
effective-typescript-main/samples/ch-intro/independent.md
---
# Item 3: Understand That Code Generation Is Independent of Types

## Things to Remember

- Code generation is independent of the type system. This means that TypeScript types cannot affect the runtime behavior of your code.
- It is possible for a program with type errors to produce code ("compile").
- TypeScript types are not available at runtime. To query a type at runtime, you need some way to reconstruct it. Tagged unions and property checking are common ways to do this.
- Some constructs, such as `class`, introduce both a TypeScript type and a value that is available at runtime.
- Because they are erased as part of compilation, TypeScript types cannot affect the runtime performance of your code.


## Code Samples

```ts
interface Square {
  width: number;
}
interface Rectangle extends Square {
  height: number;
}
type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
    //                 ~~~~~~~~~ 'Rectangle' only refers to a type,
    //                           but is being used as a value here
    return shape.height * shape.width;
    //           ~~~~~~ Property 'height' does not exist on type 'Shape'
  } else {
    return shape.width * shape.width;
  }
}
```
----

```ts
function calculateArea(shape: Shape) {
  if ('height' in shape) {
    return shape.width * shape.height;
    //     ^? (parameter) shape: Rectangle
  } else {
    return shape.width * shape.width;
  }
}
```
----

```ts
interface Square {
  kind: 'square';
  width: number;
}
interface Rectangle {
  kind: 'rectangle';
  height: number;
  width: number;
}
type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (shape.kind === 'rectangle') {
    return shape.width * shape.height;
    //     ^? (parameter) shape: Rectangle
  } else {
    return shape.width * shape.width;
    //     ^? (parameter) shape: Square
  }
}
```
----

```ts
class Square {
  width: number;
  constructor(width: number) {
    this.width = width;
  }
}
class Rectangle extends Square {
  height: number;
  constructor(width: number, height: number) {
    super(width);
    this.height = height;
  }
}
type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
    return shape.width * shape.height;
    //     ^? (parameter) shape: Rectangle
  } else {
    return shape.width * shape.width;
    //     ^? (parameter) shape: Square
  }
}
```
----

```ts
function asNumber(val: number | string): number {
  return val as number;
}
```
----

```ts
function asNumber(val: number | string): number {
  return Number(val);
}
```
----

```ts
function setLightSwitch(value: boolean) {
  switch (value) {
    case true:
      turnLightOn();
      break;
    case false:
      turnLightOff();
      break;
    default:
      console.log(`I'm afraid I can't do that.`);
  }
}
```
----

```ts
interface LightApiResponse {
  lightSwitchValue: boolean;
}
async function setLight() {
  const response = await fetch('/light');
  const result: LightApiResponse = await response.json();
  setLightSwitch(result.lightSwitchValue);
}
```
----

```ts
function add(a: number, b: number) { return a + b; }
//       ~~~ Duplicate function implementation
function add(a: string, b: string) { return a + b; }
//       ~~~ Duplicate function implementation
```
----

```ts
function add(a: number, b: number): number;
function add(a: string, b: string): string;

function add(a: any, b: any) {
  return a + b;
}

const three = add(1, 2);
//    ^? const three: number
const twelve = add('1', '2');
//    ^? const twelve: string
```
---
effective-typescript-main/samples/ch-migrate/convert-up-the-graph.md
---
# Item 82: Convert Module by Module Up Your Dependency Graph

## Things to Remember

- Start migration by adding `@types` for third-party modules and external API calls.
- Begin migrating your own modules from the bottom of the dependency graph upwards. The first module will usually be some sort of utility code. Consider visualizing the dependency graph to help you track progress.
- Resist the urge to refactor your code as you uncover odd designs. Keep a list of ideas for future refactors, but stay focused on TypeScript conversion.
- Be aware of common errors that come up during conversion. Move JSDoc types into TypeScript type annotations if necessary to avoid losing type safety as you convert.

## Code Samples

```ts
async function fetchTable() {
  const response = await fetch('/data');
  if (!response.ok) throw new Error('Failed to fetch!');
  return response.json();
}
```
----

```ts
interface TabularData {
  columns: string[];
  rows: number[][];
}
async function fetchTable(): Promise<TabularData> {
  const response = await fetch('/data');
  if (!response.ok) throw new Error('Failed to fetch!');
  return response.json();
}
```
----

```ts
class Greeting {
  constructor(name) {
    this.greeting = 'Hello';
    //   ~~~~~~~~ Property 'greeting' does not exist on type 'Greeting'
    this.name = name;
    //   ~~~~ Property 'name' does not exist on type 'Greeting'
  }
  greet() {
    return `${this.greeting} ${this.name}`;
    //             ~~~~~~~~         ~~~~ Property ... does not exist
  }
}
```
----

```ts
class Greeting {
  greeting: string;
  name: any;
  constructor(name) {
    this.greeting = 'Hello';
    this.name = name;
  }
  greet() {
    return `${this.greeting} ${this.name}`;
  }
}
```
----

```ts
const state = {};
state.name = 'New York';
//    ~~~~ Property 'name' does not exist on type '{}'
state.capital = 'Albany';
//    ~~~~~~~ Property 'capital' does not exist on type '{}'
```
----

```ts
const state = {
  name: 'New York',
  capital: 'Albany',
};  // OK
```
----

```ts
interface State {
  name: string;
  capital: string;
}
const state = {} as State;
state.name = 'New York';  // OK
state.capital = 'Albany';  // OK
```
----

```js
// @ts-check
/**
 * @param {number} num
 */
function double(num) {
  return 2 * num;
}

double('trouble');
//     ~~~~~~~~~
// Argument of type 'string' is not assignable to parameter of type 'number'
```
----

```ts
/**
 * @param {number} num
 */
function double(num) {
  return 2 * num;
}

double('trouble');  // OK
```
----

```ts
function double(num: number) {
  return 2 * num;
}

double('trouble');
//     ~~~~~~~~~
// Argument of type 'string' is not assignable to parameter of type 'number'
```
---
effective-typescript-main/samples/ch-migrate/start-loose.md
---
# Item 83: Don't Consider Migration Complete Until You Enable noImplicitAny

## Things to Remember

- Don't consider your TypeScript migration done until you adopt `noImplicitAny`. Loose type checking can mask real mistakes in type declarations.
- Fix type errors gradually before enforcing `noImplicitAny`. Give your team a chance to get comfortable with TypeScript before adopting stricter checks.## Code Samples

```ts
class Chart {
  indices: any;

  // ...
}
```
----

```ts
class Chart {
  indices: number[];

  // ...
}
```
----

```ts
getRanges() {
  for (const r of this.indices) {
    const low = r[0];
    //    ^? const low: any
    const high = r[1];
    //    ^? const high: any
    // ...
  }
}
```
----

```ts
getRanges() {
  for (const r of this.indices) {
    const low = r[0];
    //          ~~~~ Element implicitly has an 'any' type because
    //               type 'Number' has no index signature
    const high = r[1];
    //           ~~~~ Element implicitly has an 'any' type because
    //                type 'Number' has no index signature
    // ...
  }
}
```
---
effective-typescript-main/samples/ch-migrate/allowjs.md
---
# Item 81: Use allowJs to Mix TypeScript and JavaScript

## Things to Remember

- Use the `allowJs` compiler option to support mixed JavaScript and TypeScript as you transition your project.
- Get your tests and build chain working with TypeScript before beginning large-scale migration.
---
effective-typescript-main/samples/ch-migrate/write-modern-js.md
---
# Item 79: Write Modern JavaScript

## Things to Remember

- TypeScript lets you write modern JavaScript whatever your runtime environment. Take advantage of this by using the language features it enables. In addition to improving your codebase, this will help TypeScript understand your code.
- Adopt ES modules (`import`/`export`) and classes to facilitate your migration to TypeScript.
- Use TypeScript to learn about language features like classes, destructuring, and `async`/`await`.
- Check the TC39 GitHub repo and TypeScript release notes to learn about all the latest language features.

## Code Samples

```js
function Person(first, last) {
  this.first = first;
  this.last = last;
}

Person.prototype.getName = function() {
  return this.first + ' ' + this.last;
}

const marie = new Person('Marie', 'Curie');
console.log(marie.getName());
```
----

```js
class Person {
  constructor(first, last) {
    this.first = first;
    this.last = last;
  }

  getName() {
    return this.first + ' ' + this.last;
  }
}

const marie = new Person('Marie', 'Curie');
console.log(marie.getName());
```
---
effective-typescript-main/samples/ch-migrate/jsdoc-tscheck.md
---
# Item 80: Use @ts-check and JSDoc to Experiment with TypeScript

## Things to Remember

- Add "`// @ts-check`" to the top of a JavaScript file to enable type checking without converting to TypeScript.
- Recognize common errors. Know how to declare globals and add type declarations for third-party libraries.
- Use JSDoc annotations for type assertions and better type inference.
- Don't spend too much time getting your code perfectly typed with JSDoc. Remember that the goal is to convert to _.ts_!

## Code Samples

```js
// @ts-check
const person = {first: 'Grace', last: 'Hopper'};
2 * person.first
//  ~~~~~~~~~~~~ The right-hand side of an arithmetic operation must be of type
//               'any', 'number', 'bigint' or an enum type
```
----

```js
// @ts-check
console.log(user.firstName);
//          ~~~~ Cannot find name 'user'
```
----

```ts
interface UserData {
  firstName: string;
  lastName: string;
}
declare let user: UserData;
```
----

```js
// @ts-check
$('#graph').style({'width': '100px', 'height': '100px'});
// Error: Cannot find name '$'
```
----

```js
// @ts-check
$('#graph').style({'width': '100px', 'height': '100px'});
//          ~~~~~ Property 'style' does not exist on type 'JQuery<HTMLElement>'
```
----

```js
// @ts-check
const ageEl = document.getElementById('age');
ageEl.value = '12';
//    ~~~~~ Property 'value' does not exist on type 'HTMLElement'
```
----

```js
// @ts-check
const ageEl = /** @type {HTMLInputElement} */(document.getElementById('age'));
ageEl.value = '12';  // OK
```
----

```js
// @ts-check
/**
 * Gets the size (in pixels) of an element.
 * @param {Node} el The element
 * @return {{w: number, h: number}} The size
 */
function getSize(el) {
  const bounds = el.getBoundingClientRect();
  //                ~~~~~~~~~~~~~~~~~~~~~
  //     Property 'getBoundingClientRect' does not exist on type 'Node'
  return {width: bounds.width, height: bounds.height};
  //      ~~~~~ Type '{ width: any; height: any; }' is not
  //            assignable to type '{ w: number; h: number; }'
}
```
----

```js
// @ts-check
/**
 * @param {number} val
 */
function double(val) {
  return 2 * val;
}
```
----

```ts
function loadData(data) {
  data.files.forEach(async file => {
    // ...
  });
}
```
----

```ts
/**
 * @param {{
 *  files: { forEach: (arg0: (file: any) => Promise<void>) => void; };
 * }} data
 */
function loadData(data) {
  // ...
}
```
---
effective-typescript-main/samples/ch-recipes/brands.md
---
# Item 64: Consider Brands for Nominal Typing

## Things to Remember

- With nominal typing, a value has a type because you say it has a type, not because it has the same shape as that type.
- Consider attaching brands to distinguish primitive and object types that are semantically distinct but structurally identical.
- Be familiar with the various techniques for branding: properties on object types, string-based enums, private fields, and unique symbols.## Code Samples

```ts
interface Vector2D {
  x: number;
  y: number;
}
function calculateNorm(p: Vector2D) {
  return Math.sqrt(p.x ** 2 + p.y ** 2);
}

calculateNorm({x: 3, y: 4});  // OK, result is 5
const vec3D = {x: 3, y: 4, z: 1};
calculateNorm(vec3D);  // OK! result is also 5
```
----

```ts
interface Vector2D {
  type: '2d';
  x: number;
  y: number;
}
```
----

```ts
type AbsolutePath = string & {_brand: 'abs'};
function listAbsolutePath(path: AbsolutePath) {
  // ...
}
function isAbsolutePath(path: string): path is AbsolutePath {
  return path.startsWith('/');
}
```
----

```ts
function f(path: string) {
  if (isAbsolutePath(path)) {
    listAbsolutePath(path);
  }
  listAbsolutePath(path);
  //               ~~~~ Argument of type 'string' is not assignable to
  //                    parameter of type 'AbsolutePath'
}
```
----

```ts
type Meters = number & {_brand: 'meters'};
type Seconds = number & {_brand: 'seconds'};

const meters = (m: number) => m as Meters;
const seconds = (s: number) => s as Seconds;

const oneKm = meters(1000);
//    ^? const oneKm: Meters
const oneMin = seconds(60);
//    ^? const oneMin: Seconds
```
----

```ts
const tenKm = oneKm * 10;
//    ^? const tenKm: number
const v = oneKm / oneMin;
//    ^? const v: number
```
----

```ts
declare const brand: unique symbol;
export type Meters = number & {[brand]: 'meters'};
```
----

```ts
function binarySearch<T>(xs: T[], x: T): boolean {
  let low = 0, high = xs.length - 1;
  while (high >= low) {
    const mid = low + Math.floor((high - low) / 2);
    const v = xs[mid];
    if (v === x) return true;
    [low, high] = x > v ? [mid + 1, high] : [low, mid - 1];
  }
  return false;
}
```
----

```ts
type SortedList<T> = T[] & {_brand: 'sorted'};

function isSorted<T>(xs: T[]): xs is SortedList<T> {
  for (let i = 0; i < xs.length - 1; i++) {
    if (xs[i] > xs[i + 1]) {
      return false;
    }
  }
  return true;
}

function binarySearch<T>(xs: SortedList<T>, x: T): boolean {
  // ...
}
```
---
effective-typescript-main/samples/ch-recipes/optional-never.md
---
# Item 63: Use Optional Never Properties to Model Exclusive Or

## Things to Remember

- In TypeScript, "or" is "inclusive or": `A | B` means either `A`, `B`, or both.
- Consider the "both" possibility in your code, and either handle it or disallow it.
- Use tagged unions to model exclusive or where it's convenient. Consider using optional `never` properties where it isn't.

## Code Samples

```ts
interface ThingOne {
  shirtColor: string;
}
interface ThingTwo {
  hairColor: string;
}
type Thing = ThingOne | ThingTwo;
```
----

```ts
const bothThings = {
  shirtColor: 'red',
  hairColor: 'blue',
};
const thing1: ThingOne = bothThings;  // ok
const thing2: ThingTwo = bothThings;  // ok
```
----

```ts
interface OnlyThingOne {
  shirtColor: string;
  hairColor?: never;
}
interface OnlyThingTwo {
  hairColor: string;
  shirtColor?: never;
}
type ExclusiveThing = OnlyThingOne | OnlyThingTwo;
```
----

```ts
const thing1: OnlyThingOne = bothThings;
//    ~~~~~~ Types of property 'hairColor' are incompatible.
const thing2: OnlyThingTwo = bothThings;
//    ~~~~~~ Types of property 'shirtColor' are incompatible.
const allThings: ExclusiveThing = {
  //  ~~~~~~~~~ Types of property 'hairColor' are incompatible.
  shirtColor: 'red',
  hairColor: 'blue',
};
```
----

```ts
interface Vector2D {
  x: number;
  y: number;
  z?: never;
}
```
----

```ts
function norm(v: Vector2D) {
  return Math.sqrt(v.x ** 2 + v.y ** 2);
}
const v = {x: 3, y: 4, z: 5};
const d = norm(v);
//             ~ Types of property 'z' are incompatible.
```
----

```ts
interface ThingOneTag {
  type: 'one';
  shirtColor: string;
}
interface ThingTwoTag {
  type: 'two';
  hairColor: string;
}
type Thing = ThingOneTag | ThingTwoTag;
```
----

```ts
type XOR<T1, T2> =
    (T1 & {[k in Exclude<keyof T2, keyof T1>]?: never}) |
    (T2 & {[k in Exclude<keyof T1, keyof T2>]?: never});
```
----

```ts
type ExclusiveThing = XOR<ThingOne, ThingTwo>;
const allThings: ExclusiveThing = {
  //  ~~~~~~~~~ Types of property 'hairColor' are incompatible.
  shirtColor: 'red',
  hairColor: 'blue',
};
```
---
effective-typescript-main/samples/ch-recipes/values-in-sync.md
---
# Item 61: Use Record Types to Keep Values in Sync

## Things to Remember

- Recognize the fail open versus fail closed dilemma.
- Use ++Record++ types to keep related values and types synchronized.
- Consider using ++Record++ types to force choices when adding new properties to an interface.

## Code Samples

```ts
interface ScatterProps {
  // The data
  xs: number[];
  ys: number[];

  // Display
  xRange: [number, number];
  yRange: [number, number];
  color: string;

  // Events
  onClick?: (x: number, y: number, index: number) => void;
}
```
----

```ts
function shouldUpdate(
  oldProps: ScatterProps,
  newProps: ScatterProps
) {
  for (const kStr in oldProps) {
    const k = kStr as keyof ScatterProps;
    if (oldProps[k] !== newProps[k]) {
      if (k !== 'onClick') return true;
    }
  }
  return false;
}
```
----

```ts
function shouldUpdate(
  oldProps: ScatterProps,
  newProps: ScatterProps
) {
  return (
    oldProps.xs !== newProps.xs ||
    oldProps.ys !== newProps.ys ||
    oldProps.xRange !== newProps.xRange ||
    oldProps.yRange !== newProps.yRange ||
    oldProps.color !== newProps.color
    // (no check for onClick)
  );
}
```
----

```ts
interface ScatterProps {
  xs: number[];
  ys: number[];
  // ...
  onClick?: (x: number, y: number, index: number) => void;

  // Note: if you add a property here, update shouldUpdate!
}
```
----

```ts
const REQUIRES_UPDATE: Record<keyof ScatterProps, boolean> = {
  xs: true,
  ys: true,
  xRange: true,
  yRange: true,
  color: true,
  onClick: false,
};

function shouldUpdate(
  oldProps: ScatterProps,
  newProps: ScatterProps
) {
  for (const kStr in oldProps) {
    const k = kStr as keyof ScatterProps;
    if (oldProps[k] !== newProps[k] && REQUIRES_UPDATE[k]) {
      return true;
    }
  }
  return false;
}
```
----

```ts
interface ScatterProps {
  // ...
  onDoubleClick?: () => void;
}
```
----

```ts
const REQUIRES_UPDATE: Record<keyof ScatterProps, boolean> = {
  //  ~~~~~~~~~~~~~~~ Property 'onDoubleClick' is missing in type ...
  // ...
};
```
----

```ts
const PROPS_REQUIRING_UPDATE: (keyof ScatterProps)[] = [
  'xs',
  'ys',
  // ...
];
```
---
effective-typescript-main/samples/ch-recipes/exhaustiveness.md
---
# Item 59: Use Never Types to Perform Exhaustiveness Checking

## Things to Remember

- Use an assignment to the `never` type to ensure that all possible values of a type are handled (an "exhaustiveness check").
- Add a return type annotation to functions that return from multiple branches. You may still want an explicit exhaustiveness check, however.
- Consider using template literal types to ensure that every combination of two or more types is handled.

## Code Samples

```ts
type Coord = [x: number, y: number];
interface Box {
  type: 'box';
  topLeft: Coord;
  size: Coord;
}
interface Circle {
  type: 'circle';
  center: Coord;
  radius: number;
}
type Shape = Box | Circle;
```
----

```ts
function drawShape(shape: Shape, context: CanvasRenderingContext2D) {
  switch (shape.type) {
    case 'box':
      context.rect(...shape.topLeft, ...shape.size);
      break;
    case 'circle':
      context.arc(...shape.center, shape.radius, 0, 2 * Math.PI);
      break;
  }
}
```
----

```ts
interface Line {
  type: 'line';
  start: Coord;
  end: Coord;
}
type Shape = Box | Circle | Line;
```
----

```ts
function processShape(shape: Shape) {
  switch (shape.type) {
    case 'box': break;
    case 'circle': break;
    case 'line': break;
    default:
      shape
      // ^? (parameter) shape: never
  }
}
```
----

```ts
function processShape(shape: Shape) {
  switch (shape.type) {
    case 'box': break;
    case 'circle': break;
    // (forgot 'line')
    default:
      shape
      // ^? (parameter) shape: Line
  }
}
```
----

```ts
function assertUnreachable(value: never): never {
  throw new Error(`Missed a case! ${value}`);
}

function drawShape(shape: Shape, context: CanvasRenderingContext2D) {
  switch (shape.type) {
    case 'box':
      context.rect(...shape.topLeft, ...shape.size);
      break;
    case 'circle':
      context.arc(...shape.center, shape.radius, 0, 2 * Math.PI);
      break;
    default:
      assertUnreachable(shape);
      //                ~~~~~
      // ... type 'Line' is not assignable to parameter of type 'never'.
  }
}
```
----

```ts
function drawShape(shape: Shape, context: CanvasRenderingContext2D) {
  switch (shape.type) {
    case 'box':
      context.rect(...shape.topLeft, ...shape.size);
      break;
    case 'circle':
      context.arc(...shape.center, shape.radius, 0, 2 * Math.PI);
      break;
    case 'line':
      context.moveTo(...shape.start);
      context.lineTo(...shape.end);
      break;
    default:
      assertUnreachable(shape); // ok
  }
}
```
----

```ts
function getArea(shape: Shape): number {
  //                            ~~~~~~ Function lacks ending return statement and
  //                                   return type does not include 'undefined'.
  switch (shape.type) {
    case 'box':
      const [width, height] = shape.size;
      return width * height;
    case 'circle':
      return Math.PI * shape.radius ** 2;
  }
}
```
----

```ts
function getArea(shape: Shape): number {
  switch (shape.type) {
    case 'box':
      const [width, height] = shape.size;
      return width * height;
    case 'circle':
      return Math.PI * shape.radius ** 2;
    case 'line':
      return 0;
    default:
      return assertUnreachable(shape);  // ok
  }
}
```
----

```ts
function processShape(shape: Shape) {
  switch (shape.type) {
    case 'box': break;
    case 'circle': break;
    default:
      const exhaustiveCheck: never = shape;
      //    ~~~~~~~~~~~~~~~ Type 'Line' is not assignable to type 'never'.
      throw new Error(`Missed a case: ${exhaustiveCheck}`);
  }
}
```
----

```ts
function processShape(shape: Shape) {
  switch (shape.type) {
    case 'box': break;
    case 'circle': break;
    default:
      shape satisfies never
      //    ~~~~~~~~~ Type 'Line' does not satisfy the expected type 'never'.
      throw new Error(`Missed a case: ${shape}`);
  }
}
```
----

```ts
type Play = 'rock' | 'paper' | 'scissors';

function shoot(a: Play, b: Play) {
  if (a === b) {
    console.log('draw');
  } else if (
    (a === 'rock' && b === 'scissors') ||
    (a === 'paper' && b === 'rock')
  ) {
    console.log('A wins');
  } else {
    console.log('B wins');
  }
}
```
----

```ts
function shoot(a: Play, b: Play) {
  const pair = `${a},${b}` as `${Play},${Play}`;  // or: as const
  //    ^? const pair: "rock,rock" | "rock,paper" | "rock,scissors" |
  //                   "paper,rock" | "paper,paper" | "paper,scissors" |
  //                   "scissors,rock" | "scissors,paper" | "scissors,scissors"
  switch (pair) {
    case 'rock,rock':
    case 'paper,paper':
    case 'scissors,scissors':
      console.log('draw');
      break;
    case 'rock,scissors':
    case 'paper,rock':
      console.log('A wins');
      break;
    case 'rock,paper':
    case 'paper,scissors':
    case 'scissors,rock':
      console.log('B wins');
      break;
    default:
      assertUnreachable(pair);
      //                ~~~~ Argument of type "scissors,paper" is not
      //                     assignable to parameter of type 'never'.
  }
}
```
---
effective-typescript-main/samples/ch-recipes/iterate-objects.md
---
# Item 60: Know How to Iterate Over Objects

## Things to Remember

- Be aware that any objects your function receives as parameters might have additional keys.
- Use `Object.entries` to iterate over the keys and values of any object.
- Use a ++for-in++ loop with an explicit type assertion to iterate objects when you know exactly what the keys will be.
- Consider `Map` as an alternative to objects since it's easier to iterate over.

////
Check that the "Surprisingly" aside continues to work:
// verifier:reset
// verifier:prepend-subset-of-id-to-following:abc:1-5
[source,ts]
----
function foo(abc: ABC) {
let k: keyof ABC;
for (k in abc) {
// ^? let k: keyof ABC (equivalent to "a" | "b" | "c")
const v = abc[k];
//    ^? const v: string | number
}
}
----
////

## Code Samples

```ts
const obj = {
  one: 'uno',
  two: 'dos',
  three: 'tres',
};
for (const k in obj) {
  const v = obj[k];
  //        ~~~~~~ Element implicitly has an 'any' type
  //               because type ... has no index signature
}
```
----

```ts
const obj = { one: 'uno', two: 'dos', three: 'tres' };
//    ^? const obj: {
//         one: string;
//         two: string;
//         three: string;
//       }
for (const k in obj) {
  //       ^? const k: string
  // ...
}
```
----

```ts
for (const kStr in obj) {
  const k = kStr as keyof typeof obj;
  //    ^? const k: "one" | "two" | "three"
  const v = obj[k];  // OK
}
```
----

```ts
interface ABC {
  a: string;
  b: string;
  c: number;
}

function foo(abc: ABC) {
  for (const k in abc) {
    //       ^? const k: string
    const v = abc[k];
    //        ~~~~~~ Element implicitly has an 'any' type
    //               because type 'ABC' has no index signature
  }
}
```
----

```ts
const x = {a: 'a', b: 'b', c: 2, d: new Date()};
foo(x);  // OK
```
----

```ts
function foo(abc: ABC) {
  for (const kStr in abc) {
    let k = kStr as keyof ABC;
    //  ^? let k: keyof ABC (equivalent to "a" | "b" | "c")
    const v = abc[k];
    //    ^? const v: string | number
  }
}
```
----

```ts
function foo(abc: ABC) {
  for (const [k, v] of Object.entries(abc)) {
    //        ^? const k: string
    console.log(v);
    //          ^? const v: any
  }
}
```
----

```ts
function foo(abc: ABC) {
  const keys = ['a', 'b', 'c'] as const;
  for (const k of keys) {
    //       ^? const k: "a" | "b" | "c"
    const v = abc[k];
    //    ^? const v: string | number
  }
}
```
----

```ts
const m = new Map([
  //  ^? const m: Map<string, string>
  ['one', 'uno'],
  ['two', 'dos'],
  ['three', 'tres'],
]);
for (const [k, v] of m.entries()) {
  //        ^? const k: string
  console.log(v);
  //          ^? const v: string
}
```
---
effective-typescript-main/samples/ch-recipes/conditional-varargs.md
---
# Item 62: Use Rest Parameters and Tuple Types to Model Variadic Functions

## Things to Remember

- Use rest parameters and tuple types to model functions whose signature depends on the type of an argument.
- Use conditional types to model relationships between the type of one parameter and the number and type of the remaining parameters.
- Remember to label the elements of your tuple types to get meaningful parameter names at call sites.

## Code Samples

```ts
interface RouteQueryParams {
  '/': null,
  '/search': { query: string; language?: string; }
  // ...
}
```
----

```ts
function buildURL(route: keyof RouteQueryParams, params?: any) {
  return route + (params ? `?${new URLSearchParams(params)}` : '');
}

console.log(buildURL('/search', {query: 'do a barrel roll', language: 'en'}))
console.log(buildURL('/'))
```
----

```ts
buildURL('/', {query: 'recursion'});  // should be an error (no params for root)
buildURL('/search');  // should be an error (missing params)
```
----

```ts
function buildURL<Path extends keyof RouteQueryParams>(
  route: Path,
  params: RouteQueryParams[Path]
) {
  return route + (params ? `?${new URLSearchParams(params)}` : '');
}
```
----

```ts
buildURL('/search', {query: 'do a barrel roll'})
buildURL('/search', {query: 'do a barrel roll', language: 'en'})
buildURL('/search', {})
//                  ~~ Property 'query' is missing in type '{}'
```
----

```ts
buildURL('/', {query: 'recursion'});  // error, good!
//            ~~~~~~~~~~~~~~~~~~~~ Argument of type '{ query: string; }' is
//                                 not assignable to parameter of type 'null'
buildURL('/', null);  // ok
buildURL('/');  // we'd like this to be allowed
// ~~~~~ Expected 2 arguments, but got 1.
```
----

```ts
function buildURL<Path extends keyof RouteQueryParams>(
  route: Path,
  ...args: (
      RouteQueryParams[Path] extends null
      ? []
      : [params: RouteQueryParams[Path]]
    )
) {
  const params = args ? args[0] : null;
  return route + (params ? `?${new URLSearchParams(params)}` : '');
}
```
----

```ts
buildURL('/search', {query: 'do a barrel roll'})
buildURL('/search', {query: 'do a barrel roll', language: 'en'})
buildURL('/search', {})
//                  ~~ Property 'query' is missing in type '{}' ...

buildURL('/', {query: 'recursion'});
//            ~~~~~~~~~~~~~~~~~~~~ Expected 1 arguments, but got 2.
buildURL('/', null);
//            ~~~~ Expected 1 arguments, but got 2.
buildURL('/');  // ok
```
----

```ts
buildURL('/');
// ^? function buildURL<"/">(route: "/"): string
buildURL('/search', {query: 'do a barrel roll'})
// ^? function buildURL<"/search">(
//      route: "/search", params: { query: string; language?: string; }
//    ): string
```
---
